# Объекты
## Основы
Объект восьмой и единственный непримитивный тип данных в JS. Используется для хранения коллекций различных значений.
Два варианта синтаксиса создания:
```js
let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта" или *литеральная нотация*
```
Список свойств объекта необязателен. Свойство - это пара "ключ:значение", где `ключ` - это строка (имя свойства), а `значение` может быть чем угодно.
### Литералы и свойства
При использовании летерального синтаксиса в объект сразу можно поместить свойство. У каждого свойства есть ключ ("имя" или "идентификатор"). После следует двоеточие `:`, и затем значение. Несколько свойств перечисляются через запятую. Для обращения к свойствам используется запись "через точку": `user.name`. Значение м.б. любого типа. Для удаления свойства используется оператор `delete`. Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки: `"likes birds"`. Последнее свойство объекта всегда желательно заканчивать запятой, это называется "висячая запятая". Такой подход упрощает добавление, удаление и перемещение свойств.
> Объект объявленный как константа, м.б. изменен. Объявление `const` защищает от изменений только саму переменную, а не её содержимое.  
### Квадратные скобки
Используется для доступа к значению свойства ключ которого состоит из нескольких слов. Синтаксис "через точку" требует чтобы ключ был именован по правилам именования переменных. Синтаксис через квадратные скобки сработают с любым именем свойства.
```js
let user = {};

// присваивание значения свойству
user["likes birds"] = true;
```
Строка в квадр. скобках заключена в кавычки. Квадр. скобки также позволяют обратиться к свойству, имя которого м.б. результатом выражения, например, храниться в переменной. Запись "через точку" такого не позволяет.
### Вычисляемые свойства
Можно использовать квадратные скобки в литеральной нотации для создания *вычисляемого свойства*.
```js
let fruit = prompt("Какой фрукт купить?", "apple");

let bag = {
  [fruit]: 5, // имя свойства будет взято из переменной fruit
};
```
Смысл вычисляемого свойства прост: имя свойства необходимо взять из переменной. Можно использовать и более сложные выражения.
### Свойство из переменной
```js
let user = {
  name,  // тоже самое, что и name:name
  age: 30
};
```
### Ограничения на имена свойств
На свойства объекта нет ограничений связанных с зарезервированными словами, такими как "for, let, return" и т.д. Они м.б. в виде строк или символов. Все другие типы данных автоматически будут преобразованы к строке. Например если использовать число `0` в качестве ключа, то оно превратиться в строку `"0"`.
### Провера существования свойства, оператор "in"
Особенность JS-объектов в том, что можно получить доступ к любому свойству, даже если свойства не существует. При обращении к такому свойству, возвращается `undefined`.
```js
let user = {};

alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
```
Также существует специальный оператор `in`.
```js
let user = { name: "John", age: 30 };

alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует
```
Слева от оператора `in` д.б. *имя свойства*. Если опустить кавычки, то это будет означать перменную.  
В большинстве случаев достаточно сравнения с `undefined`, но это не сработает, когда значение свойства `undefined`.
### Цикл "for...in"
Используется для перебора свойств объекта:
```js
for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
```
### Упорядочение свойств объекта
Свойства упорядочены особым образом: свойство с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
> **Целочисленные свойства** - это строка, которая м.б. преобразована в целое число и обратно без изменений.  

То что было изучено в данной главе называется "простым объектом" ("plain object") или просто `Object`. В JS есть много других типов объектов:
- `Array` для хранения упорядоченных коллекций данных
- `Date` для хранения инфо. о дате и времени
- `Error` для хранения инфо. об ошибке
- ... и так далее
У них есть свои особенности, формально они не являются отдельными типами, а относятся к типу данных `Object`. Они лишь расширяют его.
## Копирование и ссылки
Фундаментальное отличие объектов от притивов явл. то, что они хранятся и копируются "по ссылке". Притивы же присваиваются и копируются "по значению".  
**Переменная хранит не сам объект, а его "адрес в памяти" - ссылку на него.** Сам объект хранится где-то в памяти. А в переменной лежит "ссылка" на эту область памяти. Когди переменная объекта копируется - копируется ссылка, сам же объект не дублируется. Копирование переменной дублирует ключ, но не сам ящик. И можно использовать любую переменную для доступа к объекту и изменения его содержимого.
### Сравнение по ссылке
Операторы равенства `==` и строго равентсва `===` для объектов работают одинаково. **Два объекта равны только в том случае, если это один и тот же объект.** Два разных объекта не будут равны друг другу, даже если они оба пусты.  
Для сравнений типа `obj1 > obj2` или сравнения с притивом `obj == 5` объекты преобразуются в примитивы.
### Клонирование и объединение объектов, Object.assign
Т.о., при копировании переменной с объектом создаётся еще одна ссылка на тот же самый объект.  
Для дублирования или копирования объекта в JS нет встроенного метода, но это можно сделать например так:
```js
// скопируем все свойства user в clone
for (let key in user) {
  clone[key] = user[key];
}
```
Также можно использовать метод `Object.assign`: `Object.assign(dest, [src1, src2, src3...])`. Этот метод скопирует все свойства объекта в другой объект и возвратит его. Если принимающий объект уже имеет свойство с таким именем, оно будет перезаписано.
### Вложенное копирование
Свойствами м.б. ссылки на другие объекты. Теперь недостаточно простого копирования, поскольку объект в свойстве будет скопирован по ссылке. А значит при копировании обе переменные в своих свойствах будут ссылаться на один и тот же объект.  
Чтобы исправить это, необходимо делать проверку, не является ли свойство объектом, и если да - то копировать и его структуру тоже. Это называется "глубокое копирование". Глубокое копирование можно реализовать используя рекурсию или метод `_.cloneDeep(obj)` из JS-библиотеки "lodash".
## Сборка мусора
Управление памятью в JS выполняется автоматически и незаметно.
### Достижимость
Основной концепт управления памятью в JS является принцип *достижимости*.
*Достижимые* значения - это те, которые доступны или используются. Они гарантированно находятся в памяти.  
1. Базовое множество достижимых значений, кот. не м.б. удалены:
- Локальные переменные и параметры текущей функции.
- Переменные и параметры других функций в текущей цепочке вложенных вызовов.
- Глобальные переменные
- (некоторые другие внутренние значения)
Такие значения называют *корнями*.
2. Любое другое значение, если оно доступно из корня по ссылке или цепочке ссылок.
Например, если в локальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, то этот объект считается достижимым. И те, на кот. он ссылается, тоже достижимы.  
В интерпретаторе JS есть фоновый процесс, кот. называется *сборщик мусора*. Он следит за всеми объектами и удаляет те, которые стали недостижимы.
### Простой пример
Если в глобальной области видимости объявлена переменная хранящая ссылку на объект, то этот объект будут достижимым. Если перезаписать значение переменной, то объект, ссылка на кот. содержала переменная, будет недостижимым и удален из памяти *сборщиком мусора*.
### Две ссылки
Если скопировать ссылку на объект из одной переменной в другую, то при перезаписи значения в одной переменной, объект все равно останется достижимым из другой переменной.
### Взаимосвязанные объекты
Имея объект в котором содержатся ссылки на объекты, в кот. в свою очередь содержатся ссылки на друг друга, все объекты будут достижимы. Если в главном объекте удалить ссылку на один из вложенных объектов, он все равно останется достижимым из второго вложенного объекта, ссылка на кот. содержится в главном объекте.  
Исходящие ссылки не имеют значения, только входящие ссылки могут сделать объект достижимым.
### Недостижимый "остров"
Вполне возможна ситуация, при кот. целый "остров" связанных объектом может стать недостижимым и удалиться из памяти.
### Внутренние алгоритмы
Основной алгоритм сборки мусора - "алгоритм пометок" (англ. "mark-and-sweep"). Согласно ему:
- Сборщик мусора "помечает" (запоминает) все корневые объекты 
- Затем он идет по их ссылкам и помечает все найденные объекты
- ...И так далее, пока не будут посещены все ссылки (достижимые от корней)
- Все непомеченные объекты удаляются.
Интерпретаторы JS применяют множество оптимизаций, чтобы сборка мусора работала быстрее и не влияла на производительность.

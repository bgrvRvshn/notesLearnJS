# Объекты
## Основы
Объект восьмой и единственный непримитивный тип данных в JS. Используется для хранения коллекций различных значений.
Два варианта синтаксиса создания:
```js
let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта" или *литеральная нотация*
```
Список свойств объекта необязателен. Свойство - это пара "ключ:значение", где `ключ` - это строка (имя свойства), а `значение` может быть чем угодно.
### Литералы и свойства
При использовании летерального синтаксиса в объект сразу можно поместить свойство. У каждого свойства есть ключ ("имя" или "идентификатор"). После следует двоеточие `:`, и затем значение. Несколько свойств перечисляются через запятую. Для обращения к свойствам используется запись "через точку": `user.name`. Значение м.б. любого типа. Для удаления свойства используется оператор `delete`. Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки: `"likes birds"`. Последнее свойство объекта всегда желательно заканчивать запятой, это называется "висячая запятая". Такой подход упрощает добавление, удаление и перемещение свойств.
> Объект объявленный как константа, м.б. изменен. Объявление `const` защищает от изменений только саму переменную, а не её содержимое.  
### Квадратные скобки
Используется для доступа к значению свойства ключ которого состоит из нескольких слов. Синтаксис "через точку" требует чтобы ключ был именован по правилам именования переменных. Синтаксис через квадратные скобки сработают с любым именем свойства.
```js
let user = {};

// присваивание значения свойству
user["likes birds"] = true;
```
Строка в квадр. скобках заключена в кавычки. Квадр. скобки также позволяют обратиться к свойству, имя которого м.б. результатом выражения, например, храниться в переменной. Запись "через точку" такого не позволяет.
### Вычисляемые свойства
Можно использовать квадратные скобки в литеральной нотации для создания *вычисляемого свойства*.
```js
let fruit = prompt("Какой фрукт купить?", "apple");

let bag = {
  [fruit]: 5, // имя свойства будет взято из переменной fruit
};
```
Смысл вычисляемого свойства прост: имя свойства необходимо взять из переменной. Можно использовать и более сложные выражения.
### Свойство из переменной
```js
let user = {
  name,  // тоже самое, что и name:name
  age: 30
};
```
### Ограничения на имена свойств
На свойства объекта нет ограничений связанных с зарезервированными словами, такими как "for, let, return" и т.д. Они м.б. в виде строк или символов. Все другие типы данных автоматически будут преобразованы к строке. Например если использовать число `0` в качестве ключа, то оно превратиться в строку `"0"`.
### Провера существования свойства, оператор "in"
Особенность JS-объектов в том, что можно получить доступ к любому свойству, даже если свойства не существует. При обращении к такому свойству, возвращается `undefined`.
```js
let user = {};

alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
```
Также существует специальный оператор `in`.
```js
let user = { name: "John", age: 30 };

alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует
```
Слева от оператора `in` д.б. *имя свойства*. Если опустить кавычки, то это будет означать перменную.  
В большинстве случаев достаточно сравнения с `undefined`, но это не сработает, когда значение свойства `undefined`.
### Цикл "for...in"
Используется для перебора свойств объекта:
```js
for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
```
### Упорядочение свойств объекта
Свойства упорядочены особым образом: свойство с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
> **Целочисленные свойства** - это строка, которая м.б. преобразована в целое число и обратно без изменений.  

То что было изучено в данной главе называется "простым объектом" ("plain object") или просто `Object`. В JS есть много других типов объектов:
- `Array` для хранения упорядоченных коллекций данных
- `Date` для хранения инфо. о дате и времени
- `Error` для хранения инфо. об ошибке
- ... и так далее
У них есть свои особенности, формально они не являются отдельными типами, а относятся к типу данных `Object`. Они лишь расширяют его.
## Копирование и ссылки
Фундаментальное отличие объектов от притивов явл. то, что они хранятся и копируются "по ссылке". Притивы же присваиваются и копируются "по значению".  
**Переменная хранит не сам объект, а его "адрес в памяти" - ссылку на него.** Сам объект хранится где-то в памяти. А в переменной лежит "ссылка" на эту область памяти. Когди переменная объекта копируется - копируется ссылка, сам же объект не дублируется. Копирование переменной дублирует ключ, но не сам ящик. И можно использовать любую переменную для доступа к объекту и изменения его содержимого.
### Сравнение по ссылке
Операторы равенства `==` и строго равентсва `===` для объектов работают одинаково. **Два объекта равны только в том случае, если это один и тот же объект.** Два разных объекта не будут равны друг другу, даже если они оба пусты.  
Для сравнений типа `obj1 > obj2` или сравнения с притивом `obj == 5` объекты преобразуются в примитивы.
### Клонирование и объединение объектов, Object.assign
Т.о., при копировании переменной с объектом создаётся еще одна ссылка на тот же самый объект.  
Для дублирования или копирования объекта в JS нет встроенного метода, но это можно сделать например так:
```js
// скопируем все свойства user в clone
for (let key in user) {
  clone[key] = user[key];
}
```
Также можно использовать метод `Object.assign`: `Object.assign(dest, [src1, src2, src3...])`. Этот метод скопирует все свойства объекта в другой объект и возвратит его. Если принимающий объект уже имеет свойство с таким именем, оно будет перезаписано.
### Вложенное копирование
Свойствами м.б. ссылки на другие объекты. Теперь недостаточно простого копирования, поскольку объект в свойстве будет скопирован по ссылке. А значит при копировании обе переменные в своих свойствах будут ссылаться на один и тот же объект.  
Чтобы исправить это, необходимо делать проверку, не является ли свойство объектом, и если да - то копировать и его структуру тоже. Это называется "глубокое копирование". Глубокое копирование можно реализовать используя рекурсию или метод `_.cloneDeep(obj)` из JS-библиотеки "lodash".
## Сборка мусора
Управление памятью в JS выполняется автоматически и незаметно.
### Достижимость
Основной концепт управления памятью в JS является принцип *достижимости*.
*Достижимые* значения - это те, которые доступны или используются. Они гарантированно находятся в памяти.  
1. Базовое множество достижимых значений, кот. не м.б. удалены:
- Локальные переменные и параметры текущей функции.
- Переменные и параметры других функций в текущей цепочке вложенных вызовов.
- Глобальные переменные
- (некоторые другие внутренние значения)
Такие значения называют *корнями*.
2. Любое другое значение, если оно доступно из корня по ссылке или цепочке ссылок.
Например, если в локальной переменной есть объект, и он имеет свойство, в котором хранится ссылка на другой объект, то этот объект считается достижимым. И те, на кот. он ссылается, тоже достижимы.  
В интерпретаторе JS есть фоновый процесс, кот. называется *сборщик мусора*. Он следит за всеми объектами и удаляет те, которые стали недостижимы.
### Простой пример
Если в глобальной области видимости объявлена переменная хранящая ссылку на объект, то этот объект будут достижимым. Если перезаписать значение переменной, то объект, ссылка на кот. содержала переменная, будет недостижимым и удален из памяти *сборщиком мусора*.
### Две ссылки
Если скопировать ссылку на объект из одной переменной в другую, то при перезаписи значения в одной переменной, объект все равно останется достижимым из другой переменной.
### Взаимосвязанные объекты
Имея объект в котором содержатся ссылки на объекты, в кот. в свою очередь содержатся ссылки на друг друга, все объекты будут достижимы. Если в главном объекте удалить ссылку на один из вложенных объектов, он все равно останется достижимым из второго вложенного объекта, ссылка на кот. содержится в главном объекте.  
Исходящие ссылки не имеют значения, только входящие ссылки могут сделать объект достижимым.
### Недостижимый "остров"
Вполне возможна ситуация, при кот. целый "остров" связанных объектом может стать недостижимым и удалиться из памяти.
### Внутренние алгоритмы
Основной алгоритм сборки мусора - "алгоритм пометок" (англ. "mark-and-sweep"). Согласно ему:
- Сборщик мусора "помечает" (запоминает) все корневые объекты 
- Затем он идет по их ссылкам и помечает все найденные объекты
- ...И так далее, пока не будут посещены все ссылки (достижимые от корней)
- Все непомеченные объекты удаляются.
Интерпретаторы JS применяют множество оптимизаций, чтобы сборка мусора работала быстрее и не влияла на производительность.
## Методы объекта, "this"
### Примеры методов
```js
user.sayHi = function() {
  alert("Привет!");
};
```
Использовали функциональное выражение, чтобы создать функцию и присвоили её свойству нашего объекта.  
Функцию, кот. является свойством объекта, называется *методом* объекта.
> **Объектно-ориентированное программирование** - когда мы пишем код, используя объекты для представления сущностей реального мира.
### Ключевое слово "this" в методах
Если методу объекта необходим доступ к инфо., кот. хранится в объекта, используется ключевое слово `this`. Значение `this` - это объект "перед точкой", кот. использовался для вызова метода.
### "this" не является фиксированным
Значение `this` вычисляется во время выполнения кода и зависит от контекста.
> **Вызов без объекта: `this == undefined`**  
В строгом режиме в таком коде значением `this` будет являться `undefined`. В нестрогом режиме значением `this` будт равен *глобальному объекту* `window` для браузера. Это исторически сложившееся поведение `this`, кот. исправляется использованием строгого режима.
> Последствия свободного `this`  
В JS `this` является "свободным", его значение вычисляется в момент вызова метода и не зависит от того, где этот метод был объявлен, а зависит от того, какой объект вызывает метод.
### У стрелочных функций нет "this"
Стрелочные функции особенные: у них нет "собственного" `this`. Если мы используем `this` внутри стрелочной функции, то его значение берется из внешней "нормальной" функции. Это полезно, когда не хотим иметь отдельное значение `this`, а брать его из внешнего контекста.
## Конструкторы, создание объектов через "new"
Для создания множества однотипных объектов используется функция-конструктор и операция `new`.
### Функция-конструктор
1. Имя фукнции-конструктора должно начинаться с большой буквы.
2. Фукнция-конструктор должна вызываться при помощи оператор `new`.
```js
function User(name) {
  this.name = name;
  this.isAdmin = false;
}

let user = new User("Вася");
```
Происходит следующее:
1. Создается новый пустой объект, и он присваивается `this`
2. Выполняется код функции, обычно модифицирует `this` добавляя туда новые свойства
3. Возвращается значение `this`
Основной целью конструкторов - удобное повторное создание однотипных объектов.  
Технически любая функция м.б. вызвана как конструктор, то есть при помощи оператор `new`. Заглавная буква в названии фукнции является всеобщим соглашением по именованию.
### Возврат значения из конструктора return
Обычно конструкторы ничего не возвращают явно. Их задача - записать все необходимое в `this`, кот. в итоге станет результатом.  
Но если `return` есть:
- при вызове `return` с объектом, будет возвращен объект, а не `this`
- при вызове `return` с примитивами, примитив будет отброшен
Другими словами, `return` с объектом возвращает объект, в любом другом случае вернет `this`. Обычно у конструкторв отсутствует `return`.
### Создание методов в конструкторе
В `this` можно добавлять не только свойства, но и методы.
## Опциональная цепочка "?."
`?.` - это безопасный способ доступа к свойствам вложенных объектов, даже если какое-либо из промежуточных свойств не существует.
### Проблема "несуществующего свойства"
Рассмотрим объект для пользователя `user`. У большинства пользователей есть адрес `user.address` с улицей `user.address.street`, но некоторые адрес не указали. В таком случае, при попытке получить свойство `user.address.street` будет ошибка. Это норм. результат, так работает JS? но во многих ситуациях удобнее было бы получать не ошибку, а просто `undefined` ("нет улицы").  
До появления `?.` для решения подобной проблемы использовался оператор `&&`.
### Опциональная цепочка
Опциональная цепочка `?.` останавливает вычисление и возвращает `undefined`, есть часть перед `?.` имеет значение `undefined` или `null`.
```js
let user = {}; // пользователь без адреса

alert( user?.address?.street ); // undefined (без ошибки)
```
Чтение адреса выполниться без ошибок, даже если объекта `user` не существует.  
Синтаксис `?.` делает необязательным только свойство перед ним, а не какое-либо последующее. Конструкция `?.` допускает, что переменная может содержать `null/undefined`. `user?.address.street` такой вызов предусматривает, что если объект `user` существует, то в нём д.б. свойство `user.address`, иначе выполнение вызовет ошибку из-за второй точки.
> **Не злоупотреблять**  
Использовать `?.` только тогда, когда допускается ситуация, что значение перед ним не существует.  

> **Переменная перед `?.` д.б. объявлена**  
Опциональная цепочка работает только с существующими переменными.
### Сокращенное вычисление
`?.` немедленно останавливает вычисление, если левой части не существует. Т.о. вызовы функций или операций можно предусмотреть.
```js
let user = null;

user?.sayHi(x++);
```
### Другие варианты применения: ?.(), ?.[]
Опциональная цепочка `?.` - это не оператор, а специальная синтаксическая конструкция, кот. также работает с функциями и квадратными скобками. Например, `?.()` используется для вызова потенциально несуществующей функции.
```js
let user1 = {
  admin() {
    alert("Я администратор");
  }
}

let user2 = {};

user1.admin?.(); // Я администратор
user2.admin?.();
```
Также существует синтаксис `?.[]`, если значение свойства требуется получить с помощью квадратных скобок `[]`, а не через точку `.`. Такой способ позволяет защититься от ошибок при доступе к свойству объекта, кот. может не быть.  
Кроме того, `?.` можно использовать совместно с `delete`: `delete user?.name; // Удалить user.name, если пользователь существует`
> **Можно использовать `?.` для безопасного чтения и удаления, но не для записи**  
Опциональная цепочка `?.` не имеет смысла в левой части присваивания.
```js
let user;

user?.name = "John"; // Ошибка, это не сработает
// это по сути то же самое что undefined = "John"
```
## Тип данных Symbol
По спецификации, в качестве ключей для свойств объекта могут использоваться только строки или символы.
### Символы
"Символ" представляет собой уникальный идентификатор. Создаются новые символы с помощью функции `Symbol()`:
```js
let id = Sybmol();
```
При создании символу можно дать описание: `let id = Symbol("id") // создается символ id с описанием (именем) "id"`;  
Символы гарантированно уникальны. Даже если создать множество символов с одинаковым описанием, это всё равно будут разные символы. Описание - это просто метка, кот. ни на что не влияет.
> **Символы не преобразуются автоматически в строки**  
Большинство типов данных в JS м.б. неявно преобразованы с строку. Символы же особенные и не преобразуются автоматически. Если необходимо то можно преобразовать явно с помощью метода `.toString()`. Или можно обратиться к свойству `symbol.descripiton`, чтобы вывести только описание.  
### "Скрытые" свойства
Символы позволяют создавать "скрытые" свойства объектов, к кот. нельзя нечаянно обратиться и перезаписать их из других частей программы.
#### Символы в литеральном объекте
Если мы хотим использовать символ при литеральном объявлении объекта `{...}`, его необходимо заключить в квадратные скобки:
```js
let id = Symbol("id");

let user = {
  name: "Вася",
  [id]: 123 // просто "id: 123" не сработает
};
```
Это вызвано тем, что нам нужно использовать значение переменной `id` в качестве ключа, а не строку "id".
#### Символы игнорируются циклом for...in
Свойства, чьи ключи - символы, не перебираются циклом `for...in`. Это - часть общего принципа "сокрытия символьных свойств". А вот `Object.assign`, в отличие от цикла `for...in`, копирует и строковые, и символьные свойства. Так и задумано. Идея состоит в том, что, когда мы клонируем или объединяем объекты, мы обычно хотим скопировать все свойства.
### Глобальные символы
Для того чтобы нам гарантированно возращалость одно и тоже значение символа существуют *глобальный реестр символов*. Мы можем создавать в нем символы и обращаться к ним позже, и при каждом таком обращении нам гарантированно будет возвращаться один и тот же символ.  
Для чтения (или, при отсутствии, создания) символа из реестра используется вызов `Symbol.for(key)`. Он проверяет глобальный реестр и, при наличии в нём символа с именем `key`, возвращает его, иначе же создается новый символ `Symbol(key)` и записывается в реестр под ключом `key`.  
Глобальный реестр символов доступен в любом месте кода.
#### Symbol.keyFor
Для глобальных символов, кроме `Symbol.for(key)`, кот. ищет символ по имени, существует обратный метод: `Symbol.keyFor(sym)`, кот. наоборот, принимает глобальный символ и возвращает его имя.  
Этот метод не будет работать для неглобальных символов. Если символ неглобальный, метод вернет `undefined`. Впрочем для любых других символов доступно свойство `description`.
### Системные символы
Существует множество "системных" символов, использующихся внутри самого JS, и мы можем использовать их, чтобы настраивать различные аспекты поведения объектов:
* Symbol.hasInstance
* Symbol.isConcatSpreadable
* Symbol.iterator
* Symbol.toPrimitive
* …и так далее.
## Преобразование объектов в примитивы
При попытке произвести с объектами операции сложения вычитания или вывести их на экран, сначало происходит их преобразование в примитивы.
1. Все объекты в логическом контексте являются `true`. Существуют лишь их численные и строковые преобразования.
2. Численные преобразования происходят, когда мы выполняем математические операции.
3. Строковые преобразования обычно происходят, когда объект используется как строка.
### Преобразование к примитивам
Три варианта преобразований (три хинта):
- `string` для преобразований объекта к строке, когда операция ожидает получить строку.
- `number` для преобр. объекта к числу, в случае математ. операций.
- `default` когда оператор "не уверен", какой тип ожидать. Например бинарный `+` может работать как со строками (объединять их), так и с числами (складывать).
Не существует хинта со значением `boleean` или каких-либо еще.  
В процессе преобразования JS пытается найти и вызвать три следующих метода объекта:
1. Вызывает `obj[Symbol.toPrimitive](hint)` - метод с символьным ключом `Symbol.toPrimitive`
2. Иначе, если хинт равен `"string"`
    * пытается вызвать `obj.toString()`, а если его нет, то `obj.valueOf()`, если он существует
3. Если хинт равен `number` или `default`
    * пытается вызвать `obj.valueOf()`, а если его нет, то `obj.toString()`, если он существует
### Symbol.toPrimitive
Метод с таким названием используется для всех преобразований.
```js
let user = {
  name: "John",
  money: 1000,

  [Symbol.toPrimitive](hint) {
    alert(`hint: ${hint}`);
    return hint == "string" ? `{name: "${this.name}"}` : this.money;
  }
};

// демонстрация результатов преобразований:
alert(user); // hint: string -> {name: "John"}
alert(+user); // hint: number -> 1000
alert(user + 500); // hint: default -> 1500
```
### Методы toString/valueOf
Эти методы не символы, а просто обычные методы объектов со строковыми именами. Они представляют устаревший способ реализации преобразований объектов.  
Если нет метода `Symbol.toPrimitive`, движок JS пытается найти эти методы и вызвать их:
* `toString -> valueOf` для хинта со значением "string"
* `valueOf -> toString` - в ином случае
Для описания одного "универсального" преобразования объекта к примитиву для всех ситуаций, достаточно создать один `toString`. В отсутствие `Symbol.toPrimitive` и `valueOf`, `toString` обработает все случаи преобразований к примитивам.
### Возвращаемые значения
Все описанные методы для преобразований объектов не обязаны возвращать именно требуемый "хинтом" тип примитива.  
**Единственное обязательное требование: методы должны возвращать примитив, а не объект.**
### Последующие операции
Операция, инициировавшая преобразование, получает примитв и затем продолжает работу с ним, производя дальнейшие проебразования.
* Математ. операции, исключая бинарный плюс, преобразует примитив к числу
* Бинарный плюс `+` сложит строки

# Объекты
## Основы
Объект восьмой и единственный непримитивный тип данных в JS. Используется для хранения коллекций различных значений.
Два варианта синтаксиса создания:
```js
let user = new Object(); // синтаксис "конструктор объекта"
let user = {};  // синтаксис "литерал объекта" или *литеральная нотация*
```
Список свойств объекта необязателен. Свойство - это пара "ключ:значение", где `ключ` - это строка (имя свойства), а `значение` может быть чем угодно.
### Литералы и свойства
При использовании летерального синтаксиса в объект сразу можно поместить свойство. У каждого свойства есть ключ ("имя" или "идентификатор"). После следует двоеточие `:`, и затем значение. Несколько свойств перечисляются через запятую. Для обращения к свойствам используется запись "через точку": `user.name`. Значение м.б. любого типа. Для удаления свойства используется оператор `delete`. Имя свойства может состоять из нескольких слов, но тогда оно должно быть заключено в кавычки: `"likes birds"`. Последнее свойство объекта всегда желательно заканчивать запятой, это называется "висячая запятая". Такой подход упрощает добавление, удаление и перемещение свойств.
> Объект объявленный как константа, м.б. изменен. Объявление `const` защищает от изменений только саму переменную, а не её содержимое.  
### Квадратные скобки
Используется для доступа к значению свойства ключ которого состоит из нескольких слов. Синтаксис "через точку" требует чтобы ключ был именован по правилам именования переменных. Синтаксис через квадратные скобки сработают с любым именем свойства.
```js
let user = {};

// присваивание значения свойству
user["likes birds"] = true;
```
Строка в квадр. скобках заключена в кавычки. Квадр. скобки также позволяют обратиться к свойству, имя которого м.б. результатом выражения, например, храниться в переменной. Запись "через точку" такого не позволяет.
### Вычисляемые свойства
Можно использовать квадратные скобки в литеральной нотации для создания *вычисляемого свойства*.
```js
let fruit = prompt("Какой фрукт купить?", "apple");

let bag = {
  [fruit]: 5, // имя свойства будет взято из переменной fruit
};
```
Смысл вычисляемого свойства прост: имя свойства необходимо взять из переменной. Можно использовать и более сложные выражения.
### Свойство из переменной
```js
let user = {
  name,  // тоже самое, что и name:name
  age: 30
};
```
### Ограничения на имена свойств
На свойства объекта нет ограничений связанных с зарезервированными словами, такими как "for, let, return" и т.д. Они м.б. в виде строк или символов. Все другие типы данных автоматически будут преобразованы к строке. Например если использовать число `0` в качестве ключа, то оно превратиться в строку `"0"`.
### Провера существования свойства, оператор "in"
Особенность JS-объектов в том, что можно получить доступ к любому свойству, даже если свойства не существует. При обращении к такому свойству, возвращается `undefined`.
```js
let user = {};

alert( user.noSuchProperty === undefined ); // true означает "свойства нет"
```
Также существует специальный оператор `in`.
```js
let user = { name: "John", age: 30 };

alert( "age" in user ); // true, user.age существует
alert( "blabla" in user ); // false, user.blabla не существует
```
Слева от оператора `in` д.б. *имя свойства*. Если опустить кавычки, то это будет означать перменную.  
В большинстве случаев достаточно сравнения с `undefined`, но это не сработает, когда значение свойства `undefined`.
### Цикл "for...in"
Используется для перебора свойств объекта:
```js
for (let key in user) {
  // ключи
  alert( key );  // name, age, isAdmin
  // значения ключей
  alert( user[key] ); // John, 30, true
}
```
### Упорядочение свойств объекта
Свойства упорядочены особым образом: свойство с целочисленными ключами сортируются по возрастанию, остальные располагаются в порядке создания.
> **Целочисленные свойства** - это строка, которая м.б. преобразована в целое число и обратно без изменений.  

То что было изучено в данной главе называется "простым объектом" ("plain object") или просто `Object`. В JS есть много других типов объектов:
- `Array` для хранения упорядоченных коллекций данных
- `Date` для хранения инфо. о дате и времени
- `Error` для хранения инфо. об ошибке
- ... и так далее
У них есть свои особенности, формально они не являются отдельными типами, а относятся к типу данных `Object`. Они лишь расширяют его.

# Типы данных
Больше структур данных и более глубокое изучение типов.
## Методы у примитивов
JS позволяет работать с примитивами как с объектами. У них есть методы. Но конечно, примитивы - не объекты.  
Ключевые различия:
Примитив:
* Это - значение "примитивного" типа
* 7 притивных типов: `string, number, boolean, symbol, null, undefined и bigint`.
Объект:
* Может хранить множество значений как свойства
* Объявляется при помощи фигурных скобок. Есть и другие виды объектов, например функции тоже являются объектами.
Существует множество встроенных объектов. Например, для кот. работают с датами, ошибками, HTML-элементами. Они имеют различные свойства и методы.  
Объекты "тяжелее" примитивов. Они нуждаются в доп. ресурсах для поддержания внутренней структуры.
### Примитив как объект
Проблемы кот. нужно было решить:
* Есть много всего, что хотелось бы сделать с примитивами. Было бы замечательно иметь возможность работать с ними через вызовы методов.
* Примитивы должны оставаться легкими и быстрыми.
Принятое решение:
* Примитивы остаются примитивами.
* JS позволяет осуществлять доступ к методам и свойствам строк, чисел, булевых значений и символов.
* Для такой работы создается специальный "объект-обертка": `String`, `Number`, `Boolean`, `Symbol`. Они имеют разный набор методов.
Например:
```js
let str = "Привет";

alert( str.toUpperCase() ); // ПРИВЕТ
```
1. В момент обращения к его свойству, создается специальный объект, кот. знает значение строки и имеет методы, как `toUpperCase()`.
2. Метод запускается и возвращает новую строку
3. Специальный объект удаляется, оставляя только примитив
Другие примитивы имеют собственные наборы методов.
> **null/undefined не имеют методов**  
Особенные примитивы являются искл. У них нет соответсвующих "объектов-оберток", и они не имеют никаких методов. К некотором смысле они "самые примитивные". Попытка доступа к свойствам такого значения возвратит ошибку.  

**Примитивы не являются объектами и они не могут хранить дополнительные данные.**
## Числа
Существует два типа:
1. Обычные числа хранятся в 64-битном формате IEE-754 (числа с плавающей точкой двойной точности). Такие числа используются чаще всего.
2. `BigInt` числа дают возможность работать с целыми числами произвольной длины.
### Способы записи числа
В JS можно использовать букву `"e"`, чтобы укоротить запись числа. Она добавляет к числу и заменяет указанное количество нулей.
```js
let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей

alert( 7.3e9 );  // 7.3 миллиардов (7,300,000,000)
```
Другими словами, `"e"` производит операцию умножения числа на 1 с указанным числом нулей.
```js
let ms = 0.000001; // 1 микросекунда

let ms = 1e-6; // шесть нулей, слева от 1
```
#### Шестнадцатеричные, двоичные и восьмеричные числа
Шестнадцатеричные числа широко используются в JS для представления цветов, кодировки символов и многого другого. Есть короткий стиль записи: `0x`, после которого указывается число.  
Не так часто используются двоичные и восьмиричные числа, но они также поддерживаются `0b` для двоичных и `0o` для восьмиричных.
```js
alert( 0xff ); // 255

let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255
```
Регистр не имеет значения. Есть только 3 системы счисления с такой поддержкой. Для других систем счисления рекомендуется использовать функцию `parseInt`.
### toString(base)
Метод `num.toString(base)` возвращает строковое представление числа `num` в системе счисления `base`:
```js
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```
`base` может варьироваться от `2` до `36` (по умолчанию `10`).  
Часто используемые:
* **base=16** - для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры м.б. `0...9` или `A..F`.
* **base=2** - обычно используется для отладки побитовых операций, цифры `0` или `1`.
* **base=36** - максимальное основание, цифры м.б. `0...9` или `A..Z`. То есть, используется весь латинский алфавит для представления числа.
### Округление
Одна из часто используемых операций. Есть несколько встроенных методов для работы с округлением:
- `Math.floor` - округление в меньшую сторону: `3.1` становиться `3`, а `-1.1` - `-2`
- `Math.ceil` - округление в большую сторону: `3.1` становиться `4`, а `-1.1` - `-1`
- `Math.round` - округлление до ближайшего целого: `3.1` становиться `3`, `3.6` - `4`, а `-1.1` - `-1`
- `Math.trunc` - производит удаление дробной части без округления: `3.1` становится `3`, а `-1.1` — `-1`
Метод `toFixed(n)` округляет число до `n` знаков и возвращает строковое представление результата.
```js
let num = 12.34;
alert( num.toFixed(1) ); // "12.3"
```
Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу `Math.round`. Результатом `toFixed` является строка. Если десятичная часть короче, чем необходимо, буду добавлены нули в конец строки.
### Неточные вычисления
Внутри JS число представлено в виде 64-битного формата IEEE-754. Для хранения числа используется 64 бита: 52 из них для хранения цифр, 11 из них для хранения положения десятичной точки (если число целое, то хранится 0), и один бит отведен на хранение знака. Если число слишком большое, оно переполнит 64-битное хранилище, JS вернет бесконечность.  
Наиболее часто встречающаяся ошибка при работе с числами - это потеря точности.
```js
alert( 0.1 + 0.2 == 0.3 ); // false

alert( 0.1 + 0.2 ); // 0.30000000000000004
```
Почему так происходит? Число храниться в памяти в бинарной форме, как последовательность бит - единиц и нулей. Но дроби, такие как `0.1`, `0.2`, кот. выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме.
Числовой формат IEEE-754 решает эту проблему путем округления до ближайшего возможного числа. Правила округления обычно не позволяют нам увидеть эту "крошечную потерю точности", но она существует.
Для обхода проблtvs наиболее надежным способом является округление с использованием метода `toFixed(n)`. Метод всегда возвращает строку. Это гарантирует, что результат будет с заданным количеством цифр в десятичной части.  
> **Два нуля**  
Другим забавным следствием внутреннего представления чисел является наличие двух нулей: `0` и `-0`. Все потому, что знак представлен отдельным битом, так что, любое число м.б. положительным и отрицательным, включаю нуль.
### Проверка: isFinite и isNaN
* `Infinity` (и `-Infinity`) - особенное численное значение, кот. ведет себя в точности как математ. бесконечность.
* NaN представляет ошибку
Эти числовые значения принадлежат типу `number`, но они не являются "обычными" числами, поэтому есть функции для их проверки:
* `isNaN(value)` преобразует значение в число и проверяет является ли оно `NaN`
Недостаточно сравнить `=== NaN`? Нет. Значение `NaN` уникально тем, что оно не является равным ничему другому, даже самому себе.
* `isFinite(value)` преобразует аргумент в число и возвращает `true`, если оно является обычным числом, т.е. не `NaN/Infinity/-Infinity`
> **Сравнение** `Object.is`
Существует специальный метод `Object.is`, кот. сравнивает значения примерно как `===`, но более надежен в двух особых случаях:
1. Работает с `NaN`: `Object.is(NaN, NaN) === true`
2. Значения `0` и `-0` разные: `Object.is(0, -0) === false`
### parseInt и parseFloat
Для явного преобразования к числу можно использовать `+` или `Number()`. Если строка не является в точности числом, то результатом будет `NaN`.  
Единственное искл. - это пробелы в начале и в конце строки, они игнорируются.  
Для чтения значения у кот. есть единица измерения, например `100px` или `12pt` в CSS или `19$` используется `parseInt` и `parseFloat`. Они читают число из строки. Если в процессе чтения возникает ошибка они возвращают полученное до ошибки число. Функция `parseInt` возвращает целое число, а `parseFloat` возвращает число с плавающей точкой.
```js
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5
```
Функции вернут `NaN`, если не смогли прочитать ни одну цифру.
```js
alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
```
### Другие математические функции
В JS встроен объект Math, кот. содержит различные математ. функции и константы.
* `Math.random()` - возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)
* `Math.max(a, b, c...)` / `Math.min(a, b, c...)` - Возвращает наибольшее/наименьшее число из перечисленных аргументов.
* `Math.pow(n, power)` - Возвращает число `n`, возведённое в степень `power`
В объекте `Math` есть множество функций и констант, включая тригонометрические функции.
## Строки
В JS любые текстовые данные явл. строками. Не существует отдельного типа "символ". Внутренний формат строк - всегда UTF-16, вне зависимости от кодировки страницы.
### Кавычки
Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки, то такую строку мы сможем вставлять произвольные выражения обернув их в `${...}`. Еще они могут занимать более одной строки.
### Спецсимволы
В строках созданных с помощью одинарных и двойных кавычек, можно использовать специмволы для перевода строки `\n`. Есть и другие, реже используемые спецсимволы. Все спецсимволы начинаются с обратного слеша, `\` - так называемого "символа экранирования". Обратный слеш служит лишь для корректного прочтения строки интерпретатором, но он не записывается в строку после её прочтения.
### Длина строки
Свойство `lenght` содержит длину строки.
> **`length` - это свойство**  
`str.length` - это числовое свойство, а не функция, добавлять скобки не нужно.
### Доступ к символам
Получить доступ к символам, кот. нзанимает позицию `pos`, можно с помощью квадратных скобок: `[pos]`. Также можно использовать метод `charAt:` str.charAt(pos).
```js
let str = `Hello`;

// получаем первый символ
alert( str[0] ); // H
alert( str.charAt(0) ); // H

// получаем последний символ
alert( str[str.length - 1] ); // o
```
Квадратные скобки - современный способ получить символ, в то время как `charAt` существует в основном по историческим причинам. Разница в том, что `[]` вернет `undefined`, а `charAt` - пустую строку.  
Также строку можно перебрать посимвольно используя `for...of`.
### Строки неизменяемы
Содержимое строки в JS нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана - она такая навсегда.
### Изменение регистра
Методы `toLowerCase()` и `toUpperCase()` меняет регистр символов. Можно также перевести в нижний регистр какой-то конкретный символ: `'Interface'[0].toLowerCase()`.
### Поиск подстроки
#### str.indexOf
Он ищет подстроку `substr` в строке `str`, начиная с позиции `pos`, и возвращает позицию, на кот. распологается совпадение, либо `-1` при отсутствии совпадений.
```js
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру
```
Необязательный второй аргумент позволяет начать поиск с определенной позиции.  
Чтобы найти все вхождения подстроки, нужно запустить `indexOf` в цикле. Каждый раз, получив очередную позицию, начинаем новый поиск со следующей.
```js
let str = 'Ослик Иа-Иа посмотрел на виадук';

let target = 'Иа'; // цель поиска

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Найдено тут: ${foundPos}` );
  pos = foundPos + 1; // продолжаем со следующей позиции
}
```
> **`str.lastIndexOf(substr, position)`**  
Это похожий метод, кот. ищет с конца строки к её началу.
#### includes, startsWith, endsWith
`str.includes(substr, pos)` возвращает `true`, если в строке `str` есть подстрока `substr`, либо `false`, если нет. Это правильный выбор, если необходимо проверить, есть ли совпадение, но позиция не нужна. Необязательный второй аргумент `str.includes` позволяет начать поиск с определенной позиции.  
Методы `str.startsWith` и `str.endsWith` проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой.
### Получение подстроки
**`str.slice(start, [, end])`** возвращает часть строки `start` до (не включая) `end`. Если аргумент `end` отсутствует, `slice` возвращает символы до конца строки. Также для `start/end` можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с *конца строки*.  
**`str.substring(start [, end])`** возвращает часть строки между `start` и `end`. Это почти то же, что и `slice`, но можно задавать `start` больше `end`. Отрицательные значения `substring`, в отличие от `slice`, не поддерживает, они интерпретируются как `0`.  
**`str.substr(start [, length])`** возвращает часть строки от `start` длина `length`. Позволяет указать длину вместо конечной позиции. Значение первого аргумента м.б. отрицательным, тогда позиция определяется с конца.
### Сравнение строк
Строки сравниваются посимвольно в алфавитном порядке.
1. Строчные буквы больше заглавных.
2. Буквы имеющие диакритические знаки идут "не по порядку".
Строки кодируются в UTF-16. Т.о. у любого символа есть соответствующий код. Есть методы позволяющие получить символ по его коду и наоборот.  
**`str.codePointAt(pos)`** возвращает код символа находящегося на позиции `pos`.  
**`String.fromCodePoint(code)`** создает символ по его коду `code`.  
Также можно добавлять юникодные символы по их кодам, используя \u с шестнадцатеричным кодом символа.
- Все строчные буквы идут после заглавных, так как их коды больше.
- Некоторые буквы, такие как `Ö`, вообще находятся вне основного алфавита. У этой буквы код больше, чем у любой буквы от `a` до `z`.
#### Сравнение строк
"Правильный" алгоритм сравнения строк можно осуществить с помощью вызова `str.localeCompare(str2)` возвращает число, которое показывает, какая строка больше в соответствии с правилами языка:
- Отрицательное число, если str меньше str2.
- Положительное число, если str больше str2.
- 0, если строки равны.

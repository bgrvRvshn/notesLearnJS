# Типы данных
Больше структур данных и более глубокое изучение типов.
## Методы у примитивов
JS позволяет работать с примитивами как с объектами. У них есть методы. Но конечно, примитивы - не объекты.  
Ключевые различия:
Примитив:
* Это - значение "примитивного" типа
* 7 притивных типов: `string, number, boolean, symbol, null, undefined и bigint`.
Объект:
* Может хранить множество значений как свойства
* Объявляется при помощи фигурных скобок. Есть и другие виды объектов, например функции тоже являются объектами.
Существует множество встроенных объектов. Например, для кот. работают с датами, ошибками, HTML-элементами. Они имеют различные свойства и методы.  
Объекты "тяжелее" примитивов. Они нуждаются в доп. ресурсах для поддержания внутренней структуры.
### Примитив как объект
Проблемы кот. нужно было решить:
* Есть много всего, что хотелось бы сделать с примитивами. Было бы замечательно иметь возможность работать с ними через вызовы методов.
* Примитивы должны оставаться легкими и быстрыми.
Принятое решение:
* Примитивы остаются примитивами.
* JS позволяет осуществлять доступ к методам и свойствам строк, чисел, булевых значений и символов.
* Для такой работы создается специальный "объект-обертка": `String`, `Number`, `Boolean`, `Symbol`. Они имеют разный набор методов.
Например:
```js
let str = "Привет";

alert( str.toUpperCase() ); // ПРИВЕТ
```
1. В момент обращения к его свойству, создается специальный объект, кот. знает значение строки и имеет методы, как `toUpperCase()`.
2. Метод запускается и возвращает новую строку
3. Специальный объект удаляется, оставляя только примитив
Другие примитивы имеют собственные наборы методов.
> **null/undefined не имеют методов**  
Особенные примитивы являются искл. У них нет соответсвующих "объектов-оберток", и они не имеют никаких методов. К некотором смысле они "самые примитивные". Попытка доступа к свойствам такого значения возвратит ошибку.  

**Примитивы не являются объектами и они не могут хранить дополнительные данные.**
## Числа
Существует два типа:
1. Обычные числа хранятся в 64-битном формате IEE-754 (числа с плавающей точкой двойной точности). Такие числа используются чаще всего.
2. `BigInt` числа дают возможность работать с целыми числами произвольной длины.
### Способы записи числа
В JS можно использовать букву `"e"`, чтобы укоротить запись числа. Она добавляет к числу и заменяет указанное количество нулей.
```js
let billion = 1e9;  // 1 миллиард, буквально: 1 и 9 нулей

alert( 7.3e9 );  // 7.3 миллиардов (7,300,000,000)
```
Другими словами, `"e"` производит операцию умножения числа на 1 с указанным числом нулей.
```js
let ms = 0.000001; // 1 микросекунда

let ms = 1e-6; // шесть нулей, слева от 1
```
#### Шестнадцатеричные, двоичные и восьмеричные числа
Шестнадцатеричные числа широко используются в JS для представления цветов, кодировки символов и многого другого. Есть короткий стиль записи: `0x`, после которого указывается число.  
Не так часто используются двоичные и восьмиричные числа, но они также поддерживаются `0b` для двоичных и `0o` для восьмиричных.
```js
alert( 0xff ); // 255

let a = 0b11111111; // бинарная форма записи числа 255
let b = 0o377; // восьмеричная форма записи числа 255
```
Регистр не имеет значения. Есть только 3 системы счисления с такой поддержкой. Для других систем счисления рекомендуется использовать функцию `parseInt`.
### toString(base)
Метод `num.toString(base)` возвращает строковое представление числа `num` в системе счисления `base`:
```js
let num = 255;

alert( num.toString(16) );  // ff
alert( num.toString(2) );   // 11111111
```
`base` может варьироваться от `2` до `36` (по умолчанию `10`).  
Часто используемые:
* **base=16** - для шестнадцатеричного представления цвета, кодировки символов и т.д., цифры м.б. `0...9` или `A..F`.
* **base=2** - обычно используется для отладки побитовых операций, цифры `0` или `1`.
* **base=36** - максимальное основание, цифры м.б. `0...9` или `A..Z`. То есть, используется весь латинский алфавит для представления числа.
### Округление
Одна из часто используемых операций. Есть несколько встроенных методов для работы с округлением:
- `Math.floor` - округление в меньшую сторону: `3.1` становиться `3`, а `-1.1` - `-2`
- `Math.ceil` - округление в большую сторону: `3.1` становиться `4`, а `-1.1` - `-1`
- `Math.round` - округлление до ближайшего целого: `3.1` становиться `3`, `3.6` - `4`, а `-1.1` - `-1`
- `Math.trunc` - производит удаление дробной части без округления: `3.1` становится `3`, а `-1.1` — `-1`
Метод `toFixed(n)` округляет число до `n` знаков и возвращает строковое представление результата.
```js
let num = 12.34;
alert( num.toFixed(1) ); // "12.3"
```
Округляет значение до ближайшего числа, как в большую, так и в меньшую сторону, аналогично методу `Math.round`. Результатом `toFixed` является строка. Если десятичная часть короче, чем необходимо, буду добавлены нули в конец строки.
### Неточные вычисления
Внутри JS число представлено в виде 64-битного формата IEEE-754. Для хранения числа используется 64 бита: 52 из них для хранения цифр, 11 из них для хранения положения десятичной точки (если число целое, то хранится 0), и один бит отведен на хранение знака. Если число слишком большое, оно переполнит 64-битное хранилище, JS вернет бесконечность.  
Наиболее часто встречающаяся ошибка при работе с числами - это потеря точности.
```js
alert( 0.1 + 0.2 == 0.3 ); // false

alert( 0.1 + 0.2 ); // 0.30000000000000004
```
Почему так происходит? Число храниться в памяти в бинарной форме, как последовательность бит - единиц и нулей. Но дроби, такие как `0.1`, `0.2`, кот. выглядят довольно просто в десятичной системе счисления, на самом деле являются бесконечной дробью в двоичной форме.
Числовой формат IEEE-754 решает эту проблему путем округления до ближайшего возможного числа. Правила округления обычно не позволяют нам увидеть эту "крошечную потерю точности", но она существует.
Для обхода проблtvs наиболее надежным способом является округление с использованием метода `toFixed(n)`. Метод всегда возвращает строку. Это гарантирует, что результат будет с заданным количеством цифр в десятичной части.  
> **Два нуля**  
Другим забавным следствием внутреннего представления чисел является наличие двух нулей: `0` и `-0`. Все потому, что знак представлен отдельным битом, так что, любое число м.б. положительным и отрицательным, включаю нуль.
### Проверка: isFinite и isNaN
* `Infinity` (и `-Infinity`) - особенное численное значение, кот. ведет себя в точности как математ. бесконечность.
* NaN представляет ошибку
Эти числовые значения принадлежат типу `number`, но они не являются "обычными" числами, поэтому есть функции для их проверки:
* `isNaN(value)` преобразует значение в число и проверяет является ли оно `NaN`
Недостаточно сравнить `=== NaN`? Нет. Значение `NaN` уникально тем, что оно не является равным ничему другому, даже самому себе.
* `isFinite(value)` преобразует аргумент в число и возвращает `true`, если оно является обычным числом, т.е. не `NaN/Infinity/-Infinity`
> **Сравнение** `Object.is`
Существует специальный метод `Object.is`, кот. сравнивает значения примерно как `===`, но более надежен в двух особых случаях:
1. Работает с `NaN`: `Object.is(NaN, NaN) === true`
2. Значения `0` и `-0` разные: `Object.is(0, -0) === false`
### parseInt и parseFloat
Для явного преобразования к числу можно использовать `+` или `Number()`. Если строка не является в точности числом, то результатом будет `NaN`.  
Единственное искл. - это пробелы в начале и в конце строки, они игнорируются.  
Для чтения значения у кот. есть единица измерения, например `100px` или `12pt` в CSS или `19$` используется `parseInt` и `parseFloat`. Они читают число из строки. Если в процессе чтения возникает ошибка они возвращают полученное до ошибки число. Функция `parseInt` возвращает целое число, а `parseFloat` возвращает число с плавающей точкой.
```js
alert( parseInt('100px') ); // 100
alert( parseFloat('12.5em') ); // 12.5
```
Функции вернут `NaN`, если не смогли прочитать ни одну цифру.
```js
alert( parseInt('a123') ); // NaN, на первом символе происходит остановка чтения
```
### Другие математические функции
В JS встроен объект Math, кот. содержит различные математ. функции и константы.
* `Math.random()` - возвращает псевдослучайное число в диапазоне от 0 (включительно) до 1 (но не включая 1)
* `Math.max(a, b, c...)` / `Math.min(a, b, c...)` - Возвращает наибольшее/наименьшее число из перечисленных аргументов.
* `Math.pow(n, power)` - Возвращает число `n`, возведённое в степень `power`
В объекте `Math` есть множество функций и констант, включая тригонометрические функции.
## Строки
В JS любые текстовые данные явл. строками. Не существует отдельного типа "символ". Внутренний формат строк - всегда UTF-16, вне зависимости от кодировки страницы.
### Кавычки
Одинарные и двойные кавычки работают, по сути, одинаково, а если использовать обратные кавычки, то такую строку мы сможем вставлять произвольные выражения обернув их в `${...}`. Еще они могут занимать более одной строки.
### Спецсимволы
В строках созданных с помощью одинарных и двойных кавычек, можно использовать специмволы для перевода строки `\n`. Есть и другие, реже используемые спецсимволы. Все спецсимволы начинаются с обратного слеша, `\` - так называемого "символа экранирования". Обратный слеш служит лишь для корректного прочтения строки интерпретатором, но он не записывается в строку после её прочтения.
### Длина строки
Свойство `lenght` содержит длину строки.
> **`length` - это свойство**  
`str.length` - это числовое свойство, а не функция, добавлять скобки не нужно.
### Доступ к символам
Получить доступ к символам, кот. нзанимает позицию `pos`, можно с помощью квадратных скобок: `[pos]`. Также можно использовать метод `charAt:` str.charAt(pos).
```js
let str = `Hello`;

// получаем первый символ
alert( str[0] ); // H
alert( str.charAt(0) ); // H

// получаем последний символ
alert( str[str.length - 1] ); // o
```
Квадратные скобки - современный способ получить символ, в то время как `charAt` существует в основном по историческим причинам. Разница в том, что `[]` вернет `undefined`, а `charAt` - пустую строку.  
Также строку можно перебрать посимвольно используя `for...of`.
### Строки неизменяемы
Содержимое строки в JS нельзя изменить. Нельзя взять символ посередине и заменить его. Как только строка создана - она такая навсегда.
### Изменение регистра
Методы `toLowerCase()` и `toUpperCase()` меняет регистр символов. Можно также перевести в нижний регистр какой-то конкретный символ: `'Interface'[0].toLowerCase()`.
### Поиск подстроки
#### str.indexOf
Он ищет подстроку `substr` в строке `str`, начиная с позиции `pos`, и возвращает позицию, на кот. распологается совпадение, либо `-1` при отсутствии совпадений.
```js
let str = 'Widget with id';

alert( str.indexOf('Widget') ); // 0, потому что подстрока 'Widget' найдена в начале
alert( str.indexOf('widget') ); // -1, совпадений нет, поиск чувствителен к регистру
```
Необязательный второй аргумент позволяет начать поиск с определенной позиции.  
Чтобы найти все вхождения подстроки, нужно запустить `indexOf` в цикле. Каждый раз, получив очередную позицию, начинаем новый поиск со следующей.
```js
let str = 'Ослик Иа-Иа посмотрел на виадук';

let target = 'Иа'; // цель поиска

let pos = 0;
while (true) {
  let foundPos = str.indexOf(target, pos);
  if (foundPos == -1) break;

  alert( `Найдено тут: ${foundPos}` );
  pos = foundPos + 1; // продолжаем со следующей позиции
}
```
> **`str.lastIndexOf(substr, position)`**  
Это похожий метод, кот. ищет с конца строки к её началу.
#### includes, startsWith, endsWith
`str.includes(substr, pos)` возвращает `true`, если в строке `str` есть подстрока `substr`, либо `false`, если нет. Это правильный выбор, если необходимо проверить, есть ли совпадение, но позиция не нужна. Необязательный второй аргумент `str.includes` позволяет начать поиск с определенной позиции.  
Методы `str.startsWith` и `str.endsWith` проверяют, соответственно, начинается ли и заканчивается ли строка определённой строкой.
### Получение подстроки
**`str.slice(start, [, end])`** возвращает часть строки `start` до (не включая) `end`. Если аргумент `end` отсутствует, `slice` возвращает символы до конца строки. Также для `start/end` можно задавать отрицательные значения. Это означает, что позиция определена как заданное количество символов с *конца строки*.  
**`str.substring(start [, end])`** возвращает часть строки между `start` и `end`. Это почти то же, что и `slice`, но можно задавать `start` больше `end`. Отрицательные значения `substring`, в отличие от `slice`, не поддерживает, они интерпретируются как `0`.  
**`str.substr(start [, length])`** возвращает часть строки от `start` длина `length`. Позволяет указать длину вместо конечной позиции. Значение первого аргумента м.б. отрицательным, тогда позиция определяется с конца.
### Сравнение строк
Строки сравниваются посимвольно в алфавитном порядке.
1. Строчные буквы больше заглавных.
2. Буквы имеющие диакритические знаки идут "не по порядку".
Строки кодируются в UTF-16. Т.о. у любого символа есть соответствующий код. Есть методы позволяющие получить символ по его коду и наоборот.  
**`str.codePointAt(pos)`** возвращает код символа находящегося на позиции `pos`.  
**`String.fromCodePoint(code)`** создает символ по его коду `code`.  
Также можно добавлять юникодные символы по их кодам, используя \u с шестнадцатеричным кодом символа.
- Все строчные буквы идут после заглавных, так как их коды больше.
- Некоторые буквы, такие как `Ö`, вообще находятся вне основного алфавита. У этой буквы код больше, чем у любой буквы от `a` до `z`.
#### Сравнение строк
"Правильный" алгоритм сравнения строк можно осуществить с помощью вызова `str.localeCompare(str2)` возвращает число, которое показывает, какая строка больше в соответствии с правилами языка:
- Отрицательное число, если str меньше str2.
- Положительное число, если str больше str2.
- 0, если строки равны.
## Массивы
`Array` - особая структура данных для хранения упорядоченных коллекций, кот. называется массив.
### Объявление
```js
let arr = new Array();
let arr = [];
```
Для второго варианта объявления в скобках мы можем указать начальные значения элементов. Элементы массива нумеруются начиная с нуля. Можно получить элемент, указав его номер в скобках `[0]`. По такому же принципу можно и заменить элемент в массиве или добавить новый к существующему.  
Общее число элементов массива содержится в его свойстве `length`. В массиве могут храниться элементы любого типа.
> **Висячая запятая**. Список элементов массива, как и список свойств объекта лучше оканчивать запятой.
### Методы pop/push, shift/unshift
*Очередь* - один из самых распространенных вариантов применения массива. В области комп. наук так называется упорядоченная коллекция элементов.  
*Стек* - структура данных.  
Массивы в JS мгут работать и как очередь, и как стек. В комп. науках структура данных делающая это возможным, называется двусторонняя очередь.  
**Методы работающие с концом массива**
- **`pop`** удаляет последний элемент из массива и возвращает его
- **`push`** добавляет элемент в конец массива  
**Методы работающие с началом массива**
- **`shift`** удаляет из массива первый элемент и возвращает его
- **`unshift`** добавляет эл. в начало массива
### Внутреннее устройство массива
Массив - это особый вид объектов. Квадр. скобки используемые для доступа к свойству `arr[0]` - это по сути обычный синтаксис доступа к свойству объекта по ключу.  
Массивы расширяют объекты, т.к. предусматривают специальные методы для работы с упорядоченными коллекциями данных, а также свойство `length`. Но в основе все равно лежит объект.  
Массив также как и объект копируется и изменяется по ссылке.  
Благодаря внутреннему представлению в JS массивы работают очень быстро. Поэтому для сохранения такой эффективности с массивом стоит работать как с "упорядоченной коллекцией данных".  
Варианты неправильного применения массива:
- добавление нечислового свойства: `arr.test = 5`
- создание "дыр": добавление `arr[0]`, затем `arr[1000]`
- заполнение массива в обратном порядке: `arr[1000]`, `arr[999]` и т.д.
При таких случаях движок JS поймет что мы работаем с массивом как с обычным объектом и способы оптимизации, используемые для массивов работать не будут.
### Эффективность
Методы `push/pop` выполняются быстро, а методы `shift/unshift` - медленно.  
Операция `shift` должна выполнить 3 действия:
1. Удалить элемент с индексом `0`
2. Сдвинуть все элементы влево, заново пронумеровать их
3. Обновить свойство `length`
**Чем больше элементов содержит массив, тем больше времени потребуется для того, чтобы их переместить, больше операций с памятью**. То же самое с `unshift`.  
`push/pop` - им не нужно ничего перемещать. Чтобы удалить эл. в конце массива, метод `pop` очищает индекс и уменьшает значение `length`.
### Перебор элементов
Один из самых старых способов перебора эл. является цикл `for` по цифровым индексам. Но возможен и другой цикл: `for...of`. Данный цикл не предоставляет доступа к номер текущего эл., только к его значению, но в большинстве случаев этого достаточно.  
Технически, т.к. массив является объектом, можно использовать и `for...in`, но на самом деле это плохая идея:
1. Он выполняет перебор всех свойств объекта, а не только цифровых
2. Оптимизирован под произвольные объекты, не массивы, и поэтому в 10-100 раз медленнее.
### Немного о "length"
Свойство `length` автомат. обновляется при изменении массива. Если быть точным это не количество элементов массива, а наибольший цифровой индекс плюс один. Например единственный эл. имеющий большой индекс, дает большую длину:
```js
let fruits = [];
fruits[123] = "Яблоко";
alert( fruits.length ); // 124
```
Свойство `length` можно перезаписать. Если мы его увеличим, ничего не произойдет. А вот если его уменьшить - массив станет короче. Этот процесс необратим. Т.о., самый простой способ очистить массив - это `arr.length = 0;`.
### new Array()
Еще один способ объявления массива. Применяется он редко. Если `new Array` вызывается с одним аргументом, кот. представляет число, он создает массив *без элементов*, но с *заданной длинной*. В таком случае все эл. будут равны `undefined`.
### Многомерные массивы
Массивы могут содержать эл., кот. тоже явл. массивами. Это можно использовать для создания многомерных массивов.
### toString
Массивы по своему реализуют метод `toString`, кот. возвращает список эл., разделенных запятыми.
```js
let arr = [1, 2, 3];

alert( arr ); // 1,2,3
alert( String(arr) === '1,2,3' ); // true
```
Массивы не имеют ни `Symbol.toPrimitive`, ни функционирующего `valueOf`, они реализуют только преобразование `toString`.
## Методы массивов
### Добавление/удаление элементов
* `arr.push(...items)` – добавляет элементы в конец,
* `arr.pop()` – извлекает элемент из конца,
* `arr.shift()` – извлекает элемент из начала,
* `arr.unshift(...items)` – добавляет элементы в начало.  
**splice**  
Так как массивы это объекты, можно попробовать `delete`.
```js
let arr = ["I", "go", "home"];

delete arr[1]; // удалить "go"

alert( arr[1] ); // undefined

// теперь arr = ["I",  , "home"];
alert( arr.length ); // 3
```
Вроде бы, элемент удален, но при проверке оказывается, что массив всё ещё имеет 3 эл. `arr.length == 3`. Это нормально, п.ч. всё, что делает `delete obj.key` - это удаляет значение с данным ключом `key`. Это нормально для объектов, но для массивов мы хотим чтобы оставшиеся эл. сдвинулись и заняли свободное место и сам массив станет короче.  
Поэтому для массива надо использовать специальные методы.
Метод `arr.splice(str)` - это универсальный "швейцарский нож" для работы с массивами: `arr.splice(index[, deleteCount, elem1, ..., elemN])`.  
Он начинает с позиции `index`, удаляет `deleteCount` элементов и вставляет `elem1, ..., elemN` на их место. Возвращает массив из удаленных элементов.
```js
let arr = ["Я", "изучаю", "JavaScript", "прямо", "сейчас"];

// удалить 3 первых элемента и заменить их другими
arr.splice(0, 3, "Давай", "танцевать");

alert( arr ) // теперь ["Давай", "танцевать", "прямо", "сейчас"]
```
Метод `splice` также может вставлять элементы без удаления, для этого достаточно установить `deleteCount` в `0`.
> **Отрицательные индексы разрешены**  
В этом и других методах массива допускается использование отрицательного индекса. Он позволяет начать отсчет элементов с конца.  

**slice** `arr.slice([start], [end])`. Он возвращает новый массив, в кот. копирует эл. начиная с индекса `start` и до `end` (не включая `end`). Оба индекса м.б. отрицательными. Можно вызвать данный метод вообще без аргументов: `arr.slice()` создает копию массива. Это часто используется, чтобы создать копию массива для дальнейших преобразований, кот. не должны менять исходный массив.  
***concat* создает новый массив, в кот. копирует данные из других массивов и доп. значения: `arr.concat(arg1, arg2...)`. Он принимает любое кол-во аргументов, кот. м.б. как массивами, так и простыми значениями. В результате мы получим, новый массив вкл. в себя эл. из `arr`, а также `arg1`, `arg2` и так далее. Если аргумент `argN` - массив, то все его эл. копируются. Иначе скопируется сам аргумент.
```js
// создать массив из: arr и [3,4], потом добавить значения 5 и 6
alert( arr.concat([3, 4], 5, 6) ); // 1,2,3,4,5,6
```
Обычно он просто копирует эл. из массивов. Другие объекты, даже если они выглядят как массивы, добавляются как есть.
```js
let arr = [1, 2];

let arrayLike = {
  0: "что-то",
  length: 1
};

alert( arr.concat(arrayLike) ); // 1,2,[object Object]
```
Но если объект имеет спец. св-во `Symbol.isConcatSpreadable`, то он обрабатывается `concat` как массив: вместо него добавляются его числовые свойства. Для корректной обработки в объекте д.б. числовые свойства и `length`.
```js
let arr = [1, 2];

let arrayLike = {
  0: "что-то",
  1: "ещё",
  [Symbol.isConcatSpreadable]: true,
  length: 2
};

alert( arr.concat(arrayLike) ); // 1,2,что-то,ещё
```
### Перебор: forEach
Метод `arr.forEach` позволяет запустить функцию, для каждого эл. массива.
```js
arr.forEach(function(item, index, array) {
  // ... делать что-то с item
});
```
Результат функции (если она вообще что-то возвращает) отбрасывается и игнорируется.
### Поиск в масссиве
#### indexOf/lastIndexOf и includes
Они имеют одинаковый синтаксис и делают по сути тоже самое что строковые аналоги, но работают с эл. массивов.
* `arr.indexOf(item, from)` ищет `item`, начиная с индекса `from`, и возвращает индекс, на кот. был найден искомый эл., в противном случае `-1`
* `arr.lastIndexOf(item, from)` - то же самое, но ищет справа налево
* `arr.includes(item, from)` - ищет `item`, начиная с индекса `from`, и возвращает `true`, если поиск успешен  
```js
let arr = [1, 0, false];

alert( arr.indexOf(0) ); // 1
alert( arr.indexOf(false) ); // 2
alert( arr.indexOf(null) ); // -1

alert( arr.includes(1) ); // true
```
Методы используеют строгое сравнение `===`. Т.о., если мы ищем `false`, он находит именно `false`, а не ноль. Если необходимо проверить наличие эл. без необходимости знать его индекс, предпочительнее использовать `arr.includes`. Кроме того он правильно обрабатывает `NaN`.
#### find и findIndex
`arr.find`:
```ja
let result = arr.find(function(item, index, array) {
  // если true - возвращается текущий элемент и перебор прерывается
  // если все итерации оказались ложными, возвращается undefined
});
```
Функция вызывается по очереди для каждого эл. массива:
- `item` - очередной эл.
- `index` - его индекс
- `array` - сам массив  
Если функция возвращает `true`, поиск прерывается и возвращается `item`. Если ничего не найдено, возвращается `undefined`.  
Метод `arr.findIndex` - по сути то же самое, но возвращает индекс, на кот. был найден эл., а не сам элемент, и `-1`, если ничего не найдено.
#### filter
Данный метод на тот случай если найденных элементов м.б. много. `arr.filter(fn)` - возвращает массив из всех подходящих элементов.
```js
let results = arr.filter(function(item, index, array) {
  // если true - элемент добавляется к результату, и перебор продолжается
  // возвращается пустой массив в случае, если ничего не найдено
});
```
### Преобразование массива
#### map
`arr.map` вызывает функцию для каждого элемента массива и возвращает массив результатов выполнения этой функции:
```js
let result = arr.map(function(item, index, array) {
  // возвращается новое значение вместо элемента
});
```
#### sort(fn)
Сортирует массив на месте, меняя в нем порядок элементов. Он возвращает отсортированный массив, но обычно возвращаемое значение игнорируется, т.к. изменяется сам массив.  
**По умолчанию элементы сортируются как строки**. Буквально, элементы преобразуются в строки при сравнении. Для строк применяется лексикографический порядок. Чтобы использовать собственный порядок сортировки, нужно предоставить функцию в качестве аргумента.
> **Функция сравнения может вернуть любое число**  
На самом деле функции сравнения требуется любое положит. число, чтобы сказать "больше", и отрицательное, чтобы сказать "меньше".  
```js
arr.sort( (a, b) => a - b );
```
#### reverse
Меняет порядок элементов в `arr` на обратный. Также возвращает массив с измененным порядком элементов.
#### split и join
Метод `str.split(delim)` разбивает строку на массив по заданному разделителю `delim`. У него есть второй необязательный числовой аргумент - ограничение на кол-во элементов в массиве. Если их больше, чем указано, то остатое массива будет отброшен.
> **Разбивка по буквам**. Вызов `split(s)` с пустым аргументов `s` разбил бы строку на массив букв.  

Метод `arr.join(glue)` делает в точности противоположное `split`. Он создает строку из элементов `arr`, вставляя `glue` между ними.
#### reduce/reduceRight
Они используются для вычисления какого-нибудь единого значения на основе всего массива.
```js
let value = arr.reduce(function(previousValue, item, index, array) {
  // ...
}, [initial]);
```
Функция применяется по очереди ко всем элементам массива и "переносит" свой результат на следующий вызов.  
Аргументы:
* `previousValue` - результат предыдущего вызова этой функции, равен `initial` при первом вызове (если передан)
* `item` - очередной эл. массива
* `index` - его индекс
* `array` - сам массив  
При вызове функции результат её вызова на предыдущем элементе массива передается как первый аргумент. Стоит думать о первом аргументе как "аккумулирующем" результат предыдущих вызовов функции. По окончании он становиться результатом `reduce`.
```js
let arr = [1, 2, 3, 4, 5];

let result = arr.reduce((sum, current) => sum + current, 0);

alert(result); // 15
```
Здесь использовался `reduce` с 2 аргументами.  
При отсутствии `initial` в качестве первого значения берется первый элемент массива, а перебор стартует со второго. Но если массив пустой, то вызов `reduce` без начального значения выдаст ошибку. Поэтому рекомендуется всегда указывать `reduce`.
Метод `arr.reduceRight` работает аналогично, но проходит по массиву справа налево.
### Array.isArray
Массивы не образуют отдельного типа. Они основаны на объектах. Поэтому `typeof` не может отличить простой объект от массива. Но есть специальный метод `Array.isArray(value)`. Он возвращает `true`, если `value` массив, и `false`, если нет.
### Большинство методов поддерживают "thisArg"
Почти все методы массивов, кот. вызывают функции - такие как `find`, `filter`, `map`, за искл. метода `sort` принимают необязательный параметр `thisArg`.
```js
arr.find(func, thisArg);
arr.filter(func, thisArg);
arr.map(func, thisArg);
// ...
// thisArg - это необязательный последний аргумент
```
Значение параметра `thisArg` становится `this` для `func`.
## Перебираемые объекты
*Перебераемые* (или *итерируемые*) объекты - это концепция, кот. позволяет использовать любой объект в цикле `for...of`.
### Symbol.iterator
Например у нас есть объект. Это не массив, но он выглядит подходящим для `for...of`.
```js
let range = {
  from: 1,
  to: 5
};
```
Чтобы сделать `range` итерируемым (и позволить `for...of` работать с ним), нам нужно добавить в объект метод с именем `Symbol.iterator`.
1. Когда цикл `for...of` запускается, он вызывает этот метод один раз (или выдает ошибку если метод не найден). Этот метод должен вернуть *итератор* - объект с методом `next`.
2. Дальше `for...of` работает только с этим *возвращенным объектом*.
3. Когда `for...of` хочет получить след. знач., он вызывает метод `next()` этого объекта.
4. Результат вызова `next()` должен иметь вид `{done: Boolean, value: any}`, где `done=true` означает, что итерация закончека, в противном случае `value` содержит очередное значение.  
Ключевая особенность: разделение ответственности.
* У самого `range` нет метода `next()`
* Вместо этого другой объект, так называемый "итератор", создается вызовом `range[Symbol.iterator]()`, и именно его `next()` генерирует значения.  
Т.о., итератор отделен от самого итерируемого объекта.
### Строка - перебираемый объект
Для строки `for...of` перебирает символы.
### Явный вызов итератора
```js
let str = "Hello";

// делает то же самое, что и
// for (let char of str) alert(char);

let iterator = str[Symbol.iterator]();

while (true) {
  let result = iterator.next();
  if (result.done) break;
  alert(result.value); // выводит символы один за другим
}
```
Получаем строковый итератор и берем из него значения. Это дает нам больше контроля над процессом, чем `for...of`.
### Итерируемые объекты и псевдомассивы
* *Итерируемые объекты* - это объекты кот. реализуют метод `Symbol.iterator`, как было описано выше.
* *Псевдомассивы* - это объекты, у кот. есть индексы и свойство `length`, то есть, они выглядят как массивы.  
Можно встретить объекты, кот. явл. и тем и другим. Но итерируемый объект м.б. не псевдомассивом. И наоборот: псевдомассив может не быть итерируемым.  
И итерируемые объекты, и псевдомассивы - это обычно не массивы, у них нет методов `push`, `pop` и т.д.
### Array.from
Универсальный метод, кот. принимает итерируемый объект или псевдомассив и делает из него "настоящий" `Array`. После этого мы уже можем использовать методы массивов.
```js
let arrayLike = {
  0: "Hello",
  1: "World",
  length: 2
};

let arr = Array.from(arrayLike); // (*)
alert(arr.pop()); // World (метод работает)
```
`Array.from` в строке `(*)` принимает объект, проверяет, явл. ли он итерируемым объектом или псевдомассивом, затем создает новый массив и копирует туда все элементы. Полный синтаксис позволяет указать необзятельную "трансформирующую" функцию. Второй аргумент м.б. функцией, кот. будет применена к каждому элементу перед добавлением в массив, а `thisArg` возволяет установить `this` для этой функции: `Array.from(obj[, mapFn, thisArg])`.
## Map и Set
Сложные структуры данных:
* Объекты для хранения именованных коллекций
* Массивы для хранения упорядоченных коллекций
Также существуют `Map` и `Set`.
### Map
Это коллекция ключ/значение, как и `Object`, но основное отличие в том, что `Map` позволяет использовать ключи любого типа.  
Методы и свойства:
* `new Map()` - создает коллекцию
* `map.set(key, value)` - записывает по ключу значение
* `map.get(key)` - возвращает значение по ключу или `undefined` если ключ отсутствует
* `map.has(key)` - возвращает `true`, если ключ присутствует, иначе `false`
* `map.delete(key)` - удаляет элемент по ключу
* `map.clear()` - очищает коллекцию от всех элементов
* `map.size` - возвращает текущее кол-во элементов  
В отличие от объектов, ключи не будут приведены к строкам. Можно использовать любые типы данных для ключей.
```js
let map = new Map();

map.set("1", "str1");    // строка в качестве ключа
map.set(1, "num1");      // цифра как ключ
map.set(true, "bool1");  // булево значение как ключ
```
**Map может использовать объекты в качестве ключей**.
```js
let john = { name: "John" };

// давайте сохраним количество посещений для каждого пользователя
let visitsCountMap = new Map();

// объект john - это ключ для значения в объекте Map
visitsCountMap.set(john, 123);

alert(visitsCountMap.get(john)); // 123
```
Объекты в качестве ключей часто применяемая возможность объекта `Map`.
> Чобы сравнивать ключи, объект `Map` использует алгорит `SameValueZero`. Это почти то же самое, что и `===`, с той лишь разницей, что `NaN` считается равным `NaN`. Так что `NaN` может использоваться в качестве ключа. Этот алгоритм не может быть заменен или модифицирован.  

> **Цепочка вызовов**  
Каждый вызов `map.set` возвращает объект map, так что мы можем объединить вызову в цепочку:
```js
map.set("1", "str1")
  .set(1, "num1")
  .set(true, "bool1");
```
### Перебор Map
Есть 4 метода:
* `map.keys()` - возовращает итерируемый объект по ключам
* `map.values()` - возвр. итер. объект по значениям
* `map.entires()` - возвр. итер. объект по парам вида `[ключ, значение]`, по умол. используется в `for...of`  
> **Используется порядок вставки**  
В отличие от обычных объектов, перебор происходит в том же порядке, в каком происходило порядок добавление элементов.  

Кроме того `Map` имеет встроенный метод `forEach`, схожий со встроенным методом массивов.
### Object.entries: Map из Object
Можно создать `Map` из обычного объекта используя `Object.entries(obj)`, кот. получает объект и возвращает массив пар ключ-значение.
### Object.fromEntries: Object из Map
Данный метод делает противоположное, получив массив пар вида `[ключ, значение]` создает из них объект.
### Set
Это особый вид коллекции: "множество" значений (без ключей), где каждое значение может появляться только один раз.  
Основные методы:
* `new Set(iterable)` - создает `Set`, и если в качестве аргумента был предоставлен итерируемый объект (обычно это массив), то копирует его знаение в новый `Set`
* `set.add(value)` - добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект `set`
* `set.delete(value)` - удаляет значение, возвр. `true`, если `value` было во множестве на момент вызова, иначе `false`
* `set.has(value)` - возвр. `true`, если значение есть, иначе `false`
* `set.clear()` - удаляет все имеющиеся значения
* `set.size` - возвр. кол-во элементов в множестве  
Основная изюминка состоит в том, что каждое значение уникально, и если при вызове `set.add()` такое значение уже есть, то ничего не произойдет. Множество `Set` лучше оптимизировано для добавлений, оно автоматически проверяет на уникальность.
### Перебор объекта Set
Можно с помощью `for...of` так и `forEach`. Функция в `forEach` у `Set` имеет 3 аргумента: значение `value`, потом снова то же самое значение `valueAgain`, и только потом целевой объект. Это сделано для совместимости с объектом `Map`, в котором колбэк `forEach` имеет 3 аргумента. Это позволяет легко заменить `Map` на `Set` и наоборот.  
`Set` имеет те же встроенные методы что и `Map`.
## WeakMap и WeakSet
Движок JS хранит значения до тех пор, пока они достижимы. Обычно свойство объекта, элементы массива или другой структуры данных считаются достижимыми и сохраняются в памяти до тех пор, пока эта структура данных содержится в памяти.  
Например, если поместить объект в массив, то до тех пор пока массив существует, объект также будет существовать в памяти, несмотря на то, что других ссылок на него нет.  
Аналогично если мы используем объект как ключ `Map`, пока сущестует `Map`, будет существ. и этот объект. Он занимает место в памят и не м.б. удален сборщиком мусора.
### WeakMap
Не продотвращает удаление объектов сборщиком мусора, когда эти объекты выступают в качесте ключей. Перве отличие от `Map` - ключи в `WeakMap` должны быть объектами, а не примитивами. Т.е. если мы используем объект в качестве ключа и ссылок на него больше не будет, то он будет удален из памяти (и из объекта `WeakMap`) автоматически.  
`WeakMap` не поддерживает перебор и методы `keys()`, `values()`, `entries()`, нет способа взять все ключи или значения из нее.  
Присутствуют след. методы:
* `weakMap.get(key)`
* `weakMap.set(key, value)`
* `weakMap.delete(key)`
* `weakMap.has(key)`
### WeakSet
Ведет себя похоже:
* можно добавлять только объекты
* объект присутствует в множестве только до тех пор, пока доступен где-то еще
* не является перебираемой  
Служит в качестве дополнительного хранилища.  
Наиболее значительным ограничением `WeakMap` и `WeakSet` явл. то, что их нельзя перебирать или взять все содержимое. Но главная их задача - быть доп. хранилищем данных для объектов, управляемых их каких-то других мест в коде.
## Object.keys, values, entries
Простые объекты также можно перебирать методами похожими на ранее описанные, но синтаксис немного отличается.
### Object.keys, values, entries
Для простых объектов доступны след. методы:
* `Object.keys(obj)` - возвр. массив ключей
* `Object.values(obj)` - -//- значений
* `Object.entries(obj)` - -//- пар `[ключ, значение]`  
Различия (например с `Map`):  
1. Синтаксис вызова: `Object.keys(obj)`, не `obj.keys()`
2. Возвращает "реальный" массив  
1). Основная причина - гибкость  
2). По истроческим причинам
> **Object.keys/values/entries игнорируют символьные свойства**  
Методы игнор. символьные свойства в качестве ключей, так же как и `for...in`. Если потребуется есть отдельный метод `Object.getOwnPropertySymbols` - возвр. массив только символьных ключей. `Reflect.ownKeys(obj)` - возвр. все ключи.  
### Трансформация объекта
Если мы хотии применить методы массива, например `map, filter` и т.д. то можно использовать `Object.entries` с последующим вызовом `Object.fromEntries`:
1. Вызов `Object.entries(obj)` возвр. массив пар ключ/значение для `obj`.
2. На нем вызывается метод массива, например `map`.
3. Используем `Object.fromEntries(array)` на результате, чтобы преобразовать его обратно в объект.
```js
let prices = {
  banana: 1,
  orange: 2,
  meat: 4,
};

let doublePrices = Object.fromEntries(
  // преобразовать в массив, затем map, затем fromEntries обратно объект
  Object.entries(prices).map(([key, value]) => [key, value * 2])
);

alert(doublePrices.meat); // 8
```
## Деструктурирующее присваивание
Это спец. синтаксис, кот. позволяет нам "расспаковывать" массивы или объекты в кучу переменных. Также она прекрасно работает с со сложными функциями, кот. имеют могут иметь много параметров, знач. по умолчанию и т.д.
### Деструктуризация массива
```js
// у нас есть массив с именем и фамилией
let arr = ["Ilya", "Kantor"]

// деструктурирующее присваивание
// записывает firstName=arr[0], surname=arr[1]
let [firstName, surname] = arr;
```
Очень удобно использовать в связке со `split` и другими методами возвр. массив.
> «Деструктурирующее присваивание» не уничтожает массив. Оно вообще ничего не делает с правой частью присваивания, его задача - только скопировать нужные значения в переменные.  

> Ненужные элементы массива можно пропустить используя запятые: `let [firstName, , title] = ["Julius", "Caesar", "Consul"];`.  

> Работает с любыми перебираемыми объектами с правой строны: `let [one, two, three] = new Set([1, 2, 3]);`.  

> Можно присваивать чему угодно с левой строны. Например можно присвоить свойству объекта: `[user.name, user.surname] = "Ilya Kantor".split(' ');`.  

> Цикл с `entries()` можно использовать с деструктуризацией для циклического перебора ключей и значений объекта или массива.  

#### Остаточные параметры "..."
Если нужно не просто получить первые значения, но и собрать все остальные, то можно добавить еще один параметр, кот. получает все остальные значения, используя оператор "остаточные параметры" - троеточие (`"..."`):
```js
let [name1, name2, ...rest] = ["Julius", "Caesar", "Consul", "of the Roman Republic"];

alert(name1); // Julius
alert(name2); // Caesar
```
Стоит обратить внимание, что `rest` явл. массивом из оставшихся эл. Вместо `rest` можно использовать любое другое название переменной, при условии перед переменной есть три точки и она стоит на последнем месте в деструктуризации.  
#### Значения по умолчанию
Если в массиве меньше значений, чем в присваивании, то ошибки не будет. Отсутствующие значения считаются неопределенными. Если нам необходимо указать значения по умолчанию, то следует использовать `=`. Значения по умолчанию м.б. сложными выражениями или функциями. Они выполняются, только если значения отсутсвуют.
### Деструктуризация объекта
```js
let {var1, var2} = {var1:…, var2:…}
```
Левая сторона содержит "шаблон" для соответствующих свойств. В простом случае это список названий переменных `{...}`.
```js
let options = {
  title: "Menu",
  width: 100,
  height: 200
};

let {title, width, height} = options;
```
Свойства присваиваются соответсвующим переменным. Порядок не имеет значения.  
Шаблон с левой стороны м.б. более сложным и определять соответствие между свойствами и переменными. Если же необходимо присвоить свойство объекта переменной с другим названием, то иожно использовать двоеточие:
```js
// { sourceProperty: targetVariable }
let {width: w, height: h, title} = options;
```
Двоеточие показывает "что: куда идет". Для потенциально сущ. свойств можно установить значения по умолчанию, используя `=`. Как и в случае с массивами, знач. по умол. м.б. любые выражения или даже функции. Они выполняться, если знач. будут отсутствовать.  
Можно также совмещать `:` и `=`:
```js
let {width: w = 100, height: h = 200, title} = options;
```
Если объект с множеством свойств, то можно взять только то что нужно.
#### Остаток объекта "..."
```js
// title = свойство с именем title
// rest = объект с остальными свойствами
let {title, ...rest} = options;
```
### Вложенная деструктуризация
Если объект или массив содержит другие вложенные объекты или массивы, то можно использовать более сложные шаблоны с левой стороны, чтобы извлечь более глубокие свойства.
```js
let options = {
  size: {
    width: 100,
    height: 200
  },
  items: ["Cake", "Donut"],
  extra: true
};

// деструктуризация разбита на несколько строк для ясности
let {
  size: { // положим size сюда
    width,
    height
  },
  items: [item1, item2], // добавим элементы к items
  title = "Menu" // отсутствует в объекте (используется значение по умолчанию)
} = options;
```
### Умные параметры функций
В ситуациях, когда функция имеет много параметров, большинство их которых не обязательно удобно использовать деструктуризацию. В реальной жизни проблема закл. в том, как запомнить порядок аргументов.  
Мы можем передать параметры как объект, и функция немедленно деструктурирует его в переменные, а также можно использовать более сложное деструктурирование с вложенными объектами и двоеточием:
```js
let options = {
  title: "My menu",
  items: ["Item1", "Item2"]
};

function showMenu({
  title = "Untitled",
  width: w = 100,  // width присваиваем в w
  height: h = 200, // height присваиваем в h
  items: [item1, item2] // первый элемент items присваивается в item1, второй в item2
}) {
  alert( `${title} ${w} ${h}` ); // My Menu 100 200
  alert( item1 ); // Item1
  alert( item2 ); // Item2
}

showMenu(options);
```
## Дата и время
Новый встр. объект `Date`. Содержит дату и время, а также методы для управления ими.
### Создание
Для создания нужно вызвать конструктор `new Date()` с одним из след. аргументов:
* `new Date()` - создать объект `Date` с текущей датой и временем
```js
let now = new Date();
alert( now ); // показывает текущие дату и время
```
* `new Date(milliseconds)` -//- с временем, равным кол-ву миллисекунд, прошедших с 1 января 1970 года UTC+0.  
Целое число, представляющее собой количество миллисекунд, прошедших с начала 1970 года, называется *таймстамп*.
* `new Date(datestring)` - елси аргумент всего один, и это строка, то из нее "прочитывается" дата.
* `new Date(year, month, hours, minutes, seconds, ms)` - создание объекта `Date` с заданными компонентами в местном часовом поясе. Обязательны только первые два аргумента.  
- `year` должен состоять из 4 цифр
- `month` начинается с `0`
- `date` день месяца, если не задан то `1`
- если параметра `hours/minutes/seconds/ms` отсутствуют, то становятся `0`  
### Получение компонентов даты
- `getFullYear()` получить год
- `getMonth()` получить месяц
- `getDate()` получить день месяца
- `getHours(), getMinutes(), getSeconds(), getMilliseconds()` - по соответствию названиям  
- `getDay()` получить день недели (начало недели приходится на воскресенье)  
**Все вышеперечисленные методы возвращают значения в соответствии с местным часовым поясом**.
- `getTime()` для заданной даты возвращает таймстамп – количество миллисекунд, прошедших с 1 января 1970 года UTC+0.
- `getTimezoneOffset()` возвращает разницу в минутах между местным часовым поясом и UTC.

# notesLearnJS
Современный учебник JavaScript
## Основы JavaScript
#### Строгий режим - "use strict"
###### use strict
Директива выглядит как строка: `use strict`. Когда она находится в начале скрипта, весь сценарий работает в "современном режиме". Над `use strict` могут быть записаны только комментарии. Также нет директивы типа `no use strict`, которрая бы возвращала движок к старому поведению. Как только мы входим в строгий режим, отменить это невозможно.
###### Консоль браузера
`use strict` по умолчанию выключен в браузерах. Иногда, когда это имеет значение можно получить неправильные результаты. Можно использовать `Shift + Enter` для ввода нескольких строк и написать в верхней строке `use strict`.

#### Переменные
###### Переменная
Переменная - это "именованное хранилище" для данных. Для объявления переменно в js используется ключевое слово `let`. Записанное в переменную значение сохраняется в области памяти, связанной с переменной. Доступ к ней можно получить используя имя переменной.  
###### Имена переменных
В js есть два ограничения, касающиеся имён переменных:
1. Имена переменных должно содержать только буквы, цифры или символы `$` и `_`.
2. Первый символ не должен быть цифрой.  

Если имена содержат несколько слов, то используется верблюжья нотация.
> Регистр имеет значение.  
> Нелатинские буквы разрешены, но не рекомендуются.  

Зарезервированные имена, неполный список: `let, class, return, function`.  

###### Константы
Это неизменяемые переменные. Попотка изменить такую переменную приведет к ошибке.  
Константы в верхнем регистре и с использованием подчёркивания объявляются, когда значение такой переменной не будет изменяться в процессе выполнения скрипта и известно до начала его выополнения. Например, `const COLOR_RED = "#F00"`. Если же значение константы не будет изменяться в процессе выполнения скрипта, но заранее не известно, то название такой переменной записывается в нижнем регистре с использованием верблюжьей нотации `pageLoadTime`.  
Несколько хороших правил:
- использовать легко читаемые имена
- избегать использования аббревиатур или коротких имён
- делать имена максимально описательными или лаконичными  

#### Типы данных
Значения в js всегда относятся к данным определенного типа. Есть 8 основных типов данных. Переменная в js может содержать любые данные. Языки программирования, в которых такое возможно, называются "динамически типизированными". Это значит, что типы данных есть, но переменные не привязаны ни к одному из них.
###### Число
Числовой тип дынных (number) представляет как целочисленные значения, так и числа с плавающей точкой. Также существуют "специальные числовые значения": `Infinity`, `-Infinity` и `NaN`.
- `Infinity` представляет собой математическую бесконечность. Это особое значение, которое больше любого числа. Получить его можно в результате деления на ноль или задать его явно: `alert(1 / 0); alert( Infinity );`
- `NaN` означает вычислительную ошибку. Это результат неправильной или неопределенной математической операции: `alert( "не число" / 2 );`. Любая операция с `NaN` возвращает `NaN`.
> Математические операции в js безопасны. Скрипт никогда не остановиться с фатальной ошибкой. В худшем случае мы получим `NaN` как результат выполнения.
###### BigInt
В js тип `number` не может содержать числа больше, чем `9007199254740991`. Это техническое ограничение вызвано их внутренним представлением. Для большинства случаев этого достаточно, но иногда нужны гигантские числа, например в криптографии. Чтобы создать значение типа `BigInt`, необходимо добавить `n` в конец числового литерала `const bigInt = 1234567890123456789012345678901234567890n;`.  
> В данный момент `BigInt` поддерживает только в браузерах Firefox, Chrome и Edge, но не поддерживается в Safari и IE.
###### Строка
Строка должна быть заключена в кавычки. Существует три типа кавычек:
- Двойные "Привет"
- Одинарные 'Привет'
- Обратные `Привет`  
Двойные или одинарные являются "простыми", между ними нет разницы для Js. Обратные имеют расширенную функциональность. Они позволяют встраивать выражения в строку, заключая их `${...}`.  
> В некоторых языках, для хранения одного символа, существует отдельный тип. В JS такого типа нет, есть только `string`. Строка может содержать 0 символов (быть пустой), один символ или множество.
###### Булевый (логический) тип
Может принимать только два значения: `true` или `false`. Булевые значения также иогут быть результатом сравнений, `let isGreater = 4 > 1`.
###### Значение "null"
Специальное значение, которое не относится ни к одному из типов. Оно формирует отдельный тип, который содержит только значение `null`. В JS `null` не является "ссылкой на существующий объект" или "нулевым указателем", как в других языках. Это просто специальное значение, которое представляет собой "ничего", "пусто" или "значение неизвестно".
###### Значение "undefined"
Специальное значение, оно формирует тип из самого себя так же, как и `null`. Оно означает, что "значение не было присвоено". Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет `undefined`:
```js
let age;

alert(age); // выведет "undefined"
```
Технически можно присвоить значение `undefined` любой переменной, но так делать не рекомендуется. Обычно `null` используется для присвоения переменной "пустого" или "неизвестного" значения, а `undefined` - для проверок, была ли переменная назначена.
###### Объекты и символы
Тип `object` - особенный. Все остальные типы - примитивные, потому что их значениями могут быть только простые значения. В объектах же хранятся коллекции или более сложные структуры данных.
Тип `symbol` используется для создания уникальных идентификаторов в объектах.
###### Оператор typeof
Оператор `typeof` возвращает тип аргумента. Синтаксические формы:
- оператор: `typeof x`
- функция: `typeof(x)`  
Вызов `typeof` возвращает строку с именем типа:
```js
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
```
1. `Math` - это встроенный объект, который предоставляет математические операции и константы.
2. Результатом вызова `typeof null` является `object`. Это официально признанная ошибка.
3. `Alert` возвращает `function`, потому что `alert` является функцией. В JS нет специального типа "функция". Функции относятся к объектному типу. Но `typeof` обрабатывает их особым образом, возвращая `"function"`.
###### Итого
В JS есть 8 основных типов:
- `number` для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном `±(253-1)`.
- `bigint` для целых чисел произвольной длины.
- `string` для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
- `boolean` для `true` / `false`.
- `null` для неизвестных значений – отдельный тип, имеющий одно значение null.
- `undefined` для неприсвоенных значений – отдельный тип, имеющий одно значение `undefined`.
- `object` для более сложных структур данных.
- `symbol` для уникальных идентификаторов.
Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.
- Имеет две формы: `typeof x` или `typeof(x)`.
- Возвращает строку с именем типа. Например, `"string"`.
- Для `null` возвращается `"object"` – это ошибка в языке, на самом деле это не объект.

#### Взаимодействие: alert, prompt, confirm
###### alert
`alert("Hello");`  
Она показывает сообщение и ждёт, пока пользователь нажмёт кнопку "Ок".
###### prompt
`result = prompt(title, [default]);`  
Отобразит модальное окно с текстом, полем для ввода и кнопками ОК/Отмена. `title` - текст для отображения в окне. `default` - необязательный параметр, уст. начальное значение в поле для текста.
> Квадратные скобки в синтаксисе `[...]` означают, что параметр факультативный, необязательный.  

Если пользователь напечатает что-либо в окне и нажмет ОК, то введенный текст будет присвоен переменной `result`. Если пользователь нажмет "Отмена" или клавишу `Esc` то переменной будет присвоено значение `null`.
###### confirm
`result = confirm(question);`  
Отображает модальное окно с текстом `question` и двумя кнопками: ОК и Отмена. Вернет `true`, если нажата кнопка ОК или `false` если "Отмена".
###### Все эти методы являеются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной частью страницы до тех пор, пока окно не будет закрыто.  
Ограничения:
- расположение окон определяется браузером
- визуальное отображение нельзя изменить  
#### Преобразование типов
Чаще всего операторы и функции автоматически приводят переданные им значения к нужноиу типу. Например, `alert` автоматически преобразует любое значение в строку. Математические операторы к числу.
###### Строковое преобразование
`String(value);`  
Когда требуется представление чего-либо в виде строки. Преобразование происходит очевидным образом: `false` становиться `"false"`, `null` становиться `"null"` и т.п.
###### Численное преобразование
Происходит в математ. функциях и выражениях. Можно использовать функцию `Number(value)`. Явное преобразование чаще применяется, когда мы ожидаем получить число из строкового контекста. Если строка не может быть явно приведена к числу, то результатом будет `NaN`.  
Правила численного преобразования:  
Значение           | Преобразуется в...
------------------ | -------------
`undefined`        | `NaN`
`null`             | `0`
`true` / `false`   | `1` / `0`
`string`           | Пробельные символы по краям обрезаются. Если остается пустая строка - `0`, иначе из непустой строки считывается число. При ошибке результат `NaN`.  

Большинство матем. операторов также производит данное преобразование.
###### Логическое преобразование
Происходит в логических операциях, но также может быть выполнено явно: `Boolean(value)`.  
Правила преобразования:  
Значение                                                                                 | Преобразуется в...
---------------------------------------------------------------------------------------- | -------------
Значения, которые интуитивно "пустые": `0`, `undefined`, `""`, `null` и `NaN`            | `false`
Все остальные значения                                                                   | `true`  

Заметим:
- Строка с нулём `"0"` - это `true`
- Строка с пробелом `" "` - это тоже `true` (любая непустая строка это true)
###### Итого
3 типа преобразований: строковое, численное и логическое.
- `Строковое` - происходит, когда нам нужно что-то вывести. Для примитивных значений работает очевидным образом.
- `Численное` - происходит в матем. операциях.
- `Логическое` - происходит в логических операциях.
#### Базовые операторы, математика
###### Термины: "унарный", "бинарный", "операнд"
*Операнд* - то, к чему применяется оператор.  
*Унарным* - называется оператор, кот. применяется к одному операнду. `let x = 1; x = -x; // оператор отрицания`  
*Бинарным* - называется оператор, кот. применяется к двум операндам. `y - x; // оператор вычитания`  
###### Математика
- сложение `+`
- вычитание `-`
- умножение `*`
- деление `/`
- взятие остатка от деления `%`
- возведение в степень `**`
###### Взятие остатка %
Результат `a % b` - это остаток от целочисленного деления `a` на `b`.  
`alert( 5 % 2 ); // 1, остаток от деления 5 на 2`  
###### Возведение в степень **
В выражении `a ** b` оператор возведения в степень умножает `a` на само себя `b` раз: `alert( 2 ** 4 ); // (2 * 2 * 2 * 2)`.  
Математически, оператор работает и для нецелых чисел: `4 ** (1/2); // 2 (степень 1/2 эквивалентна взятию квадратного корня)`.
###### Сложение строк при помощи бинарного +
Если бинарный оператор `+` применить к строкам, то он их объединяет в одну: `let s = "моя" + "строка"; // моястрока`.  
Если хотя бы один операнд является строкой, то второй тоже будет преобразован в строку: `"1" + 2; // "12"`.
Операторы работают один за другим: `2 + 2 + "1"; // будет "41", а не "221"`.  
Сложение и преобразование строк - это особенность бинарного плюса `+`. Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.
###### Приведение к числу, унарный +
Унарный плюс `+` ничего не делает с числами, но если операнд не число, унарный плюс преобразует его в число.
```js
+true; // 1
+""; // 0
```
Тоже самое, что и `Number(...)`, только короче.
```js
+apples + +oranges; // оба операнда предварительно преобразованы в числа
```
###### Приоритет операторов
Порядок выполнения операторов определяется *приоритетом*. Можно также использовать скобки, чтобы изменить приоритет. Если приоритет одинаковый, то порядок выполнения - слева направо.
Приоритет | Название | Обозначение
--------- |--------- | -----------
17 | унарный плюс | `+`
17 | унарный минус | `-`
16 | возведение в степень | `**`
15 | умножение | `*`
15 | деление | `/`
13 | сложение | `+`
13 | вычитание | `-`
3 | присваивание | `=`  

###### Присваивание
У него один из самых низких приоритетов. Поэтому, когда переменной что-либо присваивают, например `x = 2 * 2 + 1`, то сначала выполниться арифметика, а уже затем произойдет присваивание `=` с сохранением результата в `x`.
###### Присваивание = возвращает результат
Большинство операторов в JS возвращают значение. Оператор `=` не является исключением.  
Вызов `x = value` записывает `value` в `x` и *возвращает его*.
```
let a = 1;
let b = 2;

let c = 3 - (a = b + 1);
```
Результатом `(a = b + 1)` будет значение, которое присваивается переменной `a` (то есть `3`). Потом оно используется для дальнейших вычислений.
###### Сокращенная арифметика с присваиванием
Краткие записи существуют для всех арифметических и побитовых операторов: `/=, -=, *=, +=` и так далее. Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполниться после большинства других операций: `n *= 3 + 5; // сначала выполниться правая часть`
###### Инкремент\декремент
- **Инкремент** `++` увеличивает переменную на 1: `counter++; // работает как counter = counter + 1`
- **Декремент** `--` уменьшаем переменную на 1: `counter--; // работает как counter = counter - 1`
> **Важно:**  
Инкремент\декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведет к ошибке.

- "постфиксная форма": `counter++`
- "префиксная форма": `++counter`
Префиксная форма возвращает новое значение, а постфиксная форма возвращает старое (до увеличения / уменьшения числа).
```js
let counter = 1;
let a = ++counter; // 2
--------------------------
let counter = 1;
let a = counter++; // 1
```
- Если результат не используется, тогда без разницы какую форму использовать;
- Если нужно тут же использовать результат - префиксная форма;
- если нужно значение до увеличения/уменьшения - постфиксная форма.
> Можно использовать в любых выражениях. Их приоритет выше чем у большинства других операций: `let counter = 1; 2 * ++counter; // 4`

###### Побитовые операторы
Работают с 32-разрядными целыми числами на уровне их внутреннего представления. Эти операторы не являются чем-то специфичным для JS, они поддерживаются в большинстве языков программирования:
- AND(и) (`&`)
- OR(или) (`|`)
- XOR(побитовое исключающее или) (`^`)
- NOT(не) (`~`)
- LEFT SHIFT(левый сдвиг) (`<<`)
- RIGHT SHIFT(правый сдвиг) (`>>`)
- ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) (`>>>`)
Они используются редко, когда возникает необходимость оперировать с числами на очень низком (побитовом) уровне.
###### Оператор "запятая"
Предоставляет возможность вычислять несколько выражений, разделяя их запятой `,`. Каждое выражение выполняется, но возвращается результат только последнего. Например:
```js
let a = (1 + 2, 3 + 4);

alert( a ); // 7 (результат вычисления 3 + 4)
```
Первое выражение выполняется, а результат отбрасывается. Затем идет второе, выражение выполняется и возвращает результат.
> **Запятая имеет очень низкий приоритет**  
Ниже `=`, поэтому скобки важны в приведенном выше примере.  

Иногда используется в составе более сложных конструкций, чтобы сделать несколько действий в одной строке. Например: `for (a = 1, b = 3, c = a * b; a < 10; a++) { ... }; // три операции в одной строке`.  
Обычно это не улучшает читабельность кода.
#### Операторы сравнения
###### Результат сравнения имеет логический тип
- `true` - означает "да", "верно", "истнина"
- `false` - означает "нет", "неверно", "ложь" 
###### Сравнение строк
Чтобы определить, что одна строка больше другой, используется "алфавитный" или "лексикографический" порядок, другими словами сравниваются посимвольно.
```js
alert( 'Сонный' > 'Сон' ); // true
```
Алгоритм сравнения:
1. Сначала сравниваются первые символы строк.
2. Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй. Сравнение завершено.
3. Если первые символы равны, то таким же образом сравниваются уже вторые символы строк. 
4. Сравнение продолжается, пока не закончится одна из строк.
5. Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.
> Используется кодировка Unicode, а не настоящий алфавит
В JS строчные буквы больше заглавных, потому они имеют больший код во внутренней таблице кодирования.  

###### Сравнение разных типов
При сравнении значений разных типов JS приводит каждое из них к числу:
```js
alert( "2" > 1 ); // true, строка "2" становиться числом 2
```
Логическое значение `true` становиться `1`, а `false` - `0`.
###### Строгое сравнение
Использование обычного сравнения `==` может вызывать проблемы. Оно не отличает `0` от `false`. Это происходит из-за того, что операнды разных типов преобразуются оператором `==` к числу.  
**Оператор строгого равенства `===` проверяет равенство без приведения типов**.  
Если переменные имеют разные типы, то проверка немедленно вернет `false` без попытки их преобразования.
###### Сравнение с null и undefined
При строгом равенстве `===` эти значения различны, т.к. различны их типы.  
При нестрогом равенстве `==` эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.  
При использовании математических операторов и других операторов сравнения `< > <= >=` значения `null/undefined` преобразуются к числам: `null` становиться `0`, а `undefined` - `NaN`.
- с `undefined/null` использовать только строгое равенство
- не использовать сравнения `>= > < <=` с переменными, которые могут применять значения `null/undefined`
###### Итого
- операторы сравнения возвращают значения логического типа
- строки сравниваются посимвольно в лексикографическом порядке
- значения разных типов при сравнении приводятся к числу. Исключение составляет сравнение с помощью строгого равенства/неравенства
- значения `null` и `undefined` равны `==` друг другу и не равны любому другому значению
- хорошей идеей будет сделать отдельную проверку на `null/undefined`
#### Условное ветвление: if, '?'
Инструкция `if(...)` вычисляет условие в скобках и, если результат `true`, то выполняет блок кода. Инструкция преобразует результат к логическому типу.
#### Логические операторы
В JS есть 3 логических оператора: `||` (ИЛИ), `&&` (И) и `!` (НЕ). Данные операторы могут применяться к значениям любых типов. Полученный результат также может иметь любой тип.
###### || (ИЛИ)
В случае, если какой-либо из аргументов `true`, он вернет `true`, иначе `false`.  
Существует 4 возможные логические комбинации:
```js
alert( true || true ); // true
alert( false || true ); // true
alert( true || false ); // true
alert( false || false ); // false
```
###### ИЛИ "||" находит первое истинное значение
```js
result = value1 || value2 || value3;
```
Оператор выполняет след. действия:
- вычисляет операнды слева направо
- каждый операнд конвертирует в логическое значение. Если результат `true`, останавливается и возвращает исходное значение этого операнда.
- если все операнды явл. ложными (`false`), возвращает последний из них.  
Значения возвращаются в исходном виде, без преобразования. Другими словами, цепочка `||` возвращает первое истинное значение или последнее, если такое значение не найдено.
1. **Получение первого истинного значения из списка переменных или выражений**.
```js
let currentUser = null;
let defaultUser = "Jonh";

let name = currentUser || defaultUser || "unnamed";

alert( name ); // выбирается "Jonh" - первое истинное значение
```
2. **Сокращенное вычисление**  
Операндами м.б. как отдельные значения, так и произвольные выражения. ИЛИ вычисляет их слева направо. Вычисления останавливаются при достижении первого истинного значения. Это называется "сокращенным вычислением", поскольку второй операнд вычисляется только в том случае, если первого недостаточно для вычисления всего выражения.  
В приведенном ниже примере `x` не измениться:
```js
let x;

true || (x = 1);

alert(x); // undefined, потому что (x = 1) не вычисляется
```
Если бы первый аргумент имел значение `false`, то `||` приступил бы к вычислению второго и выполнил операцию присваивания.
###### && (И)
Возвращает `true`, если оба аргумента истинны, а иначе - `false`
###### И "&&" находит первое ложное значение
При нескольких подряд операторах:
```js
result = value1 && value2 && value3;
```
- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. Если результат `false`, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращает последний.
Другими словами, И возвращает первое ложное значение, Или последнее, если ничего не найдено.
> **Приоритет оператора `&&` больше, чем у `||`**  

Как и оператор ИЛИ, И `&&` может иногда заменять `if`:
```js
let x = 1;

(x > 0) && alert( 'Greater than zero!' );
```
`alert` сработает, если в левой части будет `true`.
###### ! (НЕ)
Оператор принимает один аргумент и выполняет след. действия:
1. Сначала приводит аргумент к логическому типу `true/false`.
2. Затем возвращает противоположное значение.
```js
alert( !true ); // false
alert( !0 ); / true
```
В частности, двойное НЕ используется для преобразования значений к логическому типу:
```js
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```
То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его. В конце мы имеем простое преобразование значения в логическое. То же самое `Boolean`.
> Приоритет НЕ `!` является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед `&&` или `||`.
#### Оператор объединения с null "??"
> **Новая возможность**
Эта возможность была добавлена недавно, в старых браузерах может понадобиться полифил.  

Представляет собой `??`. Результат выражения `a ?? b`:
- `а`, если значение `a` определено,
- `b`, если значение `a` не определено.
То есть оператор `??` возвращает первый аргумент, если он не `null/undefined`, иначе второй.
По сути это всего лишь новый более удобный синтаксис, по старому это может быть записано: `(a !== null && a != undefined) ? a : b;`.  
Можно также использовать последовательность из нескольких операторов `??`, чтобы получить первое значение из списка, которое не является `null/undefined`.
###### Сравнение с ||
Оператор ИЛИ `||` можно использовать для того же, что и `??`.
Важное различие между ними:
- `||` возвращает первое *истинное* значение.
- `??` возвращает первое *определенное* значение.
Проще говоря, оператор `||` не различает `false, 0, "", null/undefined`. Для него все они являются ложными значениями. Однако часто требуется использовать значение по умолчанию только тогда, когда переменная является `null/undefined`. Ведь именно тогда значение действительно неизвестно.не определено.
###### Приоритет
Имеет низкий приоритет `5`. Вычисляется до `=` и `?`, но после большинства других операций. Следует использовать скобки при работе с оператором `??`.
###### Использование ?? вместе с && или ||
JS запрещает использование оператора `??` вместе с `&&` и `||`, если только приоритет не указан явно в круглых скобках. Такое ограничение было описано в спецификациях языка, чтобы избежать ошибок при замене оператора `||` на `??`. Необходимо использовать круглые скобки, чтобы обойти это ограничение.
###### Итого
- Это быстрый способ выбрать первое "определенное" значение из списка.
- Имеет очень низкий приоритет
- Запрещено использовать с `||` или `&&` без скобок.
#### Циклы while и for
##### Цикл "while"
```js
while (condition) {
  // код
  // также называемый `телом цикла`
}
```
Код из тела цикла выполняется, пока условие `condition` истинно.  
Одно выполнение цикла называется *итерация*. Повторение цикла вечно невозможно, браузер остановит "подвисший" скрипт, а js на стороне сервера "убьет" процесс.  
Любое выражение или переменная может быть условием цикла, а не только сравнение: условие `while` вычисляется и преобразуется в логическое значение.  
> Фигурные скобки не требуются для тела цикла из одной строки.  

##### Цикл "do...while"
```js
do {
  // тело цикла
} while (condition);
```
Используется для размещения проверки условия под целом цикла. Цикл сначала выполнит тело, а затем проверит условие `condition`. Такая форма синтаксиса используется если необходимо чтобы тело цикла выполнилось **хотя бы один раз**, даже условие окажется ложным.
##### Цикл "for"
```js
for (начало; условие; шаг) {
  // тело цикла
}
```
*Начало* выполняется один раз, затем каждая итерация заключается в проверка условия, после которой выполняется *тело* и *шаг*.
```js
for (let i = 0; i < 3; i++) {
  alert(i);
}
```
> **Встроенное объявление переменной**
Такие переменные существуют только внутри цикла
##### Пропуск частей "for"
Любая часть `for` может быть пропущена: `for (;;) { // будет выполняться вечно }`. При этом точки с запятой должны присутствовать, иначе будет ошибка синтаксиса.
##### Прерывание цикла: "break"
Обычно цикл завершается при вычислении условия в `false`. Но можно выйти в любой момент с помощью директива `break`. Данная директива полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на `alert`. Отлично подходит для тех случаев, когда условие, по которому нужно прерваться, находиться посередине.
##### Переход к следующей итерации: continue
При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все еще истинно).
> Нельзя использовать `break/continue` с тернарным опертором `?`.  
##### Метки для break/continue
Это необходимо для того чтобы выйти из нескольких уровней цикла сразу. Метка имеет вид идентификатора с двоеточием перед циклом:
```js
labelName: for (...) {
  ...
}
```
Вызов `break <labelName>` ищет ближайший внешний цикл с такой меткой и переходит в его конец.
```js
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Значение на координатах (${i},${j})`, '');

    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)

    // сделать что-нибудь со значениями...
  }
}

alert('Готово!');
```
Директива `continue` также может быть использована с меткой. В этом случае управление перейдет на следующую итерацию цикла с меткой.
> Метки не позволяют передавать управление в произвольное место кода. Вызов `break/continue` возможен только внутри цикла, и метка должна находиться где-то выше этой директивы.
###### Итого
3 вида циклов:
- `while` - проверяет условие перед каждой итерацией
- `do...while` - проверяет условие после каждой итерации
- `for (;;)` - проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.
Чтобы организовать бесконечный цикл, используют конструкцию `while(true)`. При этом он, как и любой другой цикл, может быть прерван директивой `break`.  
Если на данный итерации цикла делать больше нечего, но полностью прекращать цикл не следует - используют директиву `continue`.  
Обе эти директивы поддерживают *метки*, которые ставятся перед циклом. Метки - единственный способ для `break/continue` выйти за пределы текущего цикла, повлиять на выполнение внешнего.  
Метки не позволяют прыгнуть в произвольное место кода, в JS нет такой возможности.

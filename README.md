# notesLearnJS
Современный учебник JavaScript
## Основы JavaScript
#### Строгий режим - "use strict"
###### use strict
Директива выглядит как строка: `use strict`. Когда она находится в начале скрипта, весь сценарий работает в "современном режиме". Над `use strict` могут быть записаны только комментарии. Также нет директивы типа `no use strict`, которрая бы возвращала движок к старому поведению. Как только мы входим в строгий режим, отменить это невозможно.
###### Консоль браузера
`use strict` по умолчанию выключен в браузерах. Иногда, когда это имеет значение можно получить неправильные результаты. Можно использовать `Shift + Enter` для ввода нескольких строк и написать в верхней строке `use strict`.

#### Переменные
###### Переменная
Переменная - это "именованное хранилище" для данных. Для объявления переменно в js используется ключевое слово `let`. Записанное в переменную значение сохраняется в области памяти, связанной с переменной. Доступ к ней можно получить используя имя переменной.  
###### Имена переменных
В js есть два ограничения, касающиеся имён переменных:
1. Имена переменных должно содержать только буквы, цифры или символы `$` и `_`.
2. Первый символ не должен быть цифрой.  

Если имена содержат несколько слов, то используется верблюжья нотация.
> Регистр имеет значение.  
> Нелатинские буквы разрешены, но не рекомендуются.  

Зарезервированные имена, неполный список: `let, class, return, function`.  

###### Константы
Это неизменяемые переменные. Попотка изменить такую переменную приведет к ошибке.  
Константы в верхнем регистре и с использованием подчёркивания объявляются, когда значение такой переменной не будет изменяться в процессе выполнения скрипта и известно до начала его выополнения. Например, `const COLOR_RED = "#F00"`. Если же значение константы не будет изменяться в процессе выполнения скрипта, но заранее не известно, то название такой переменной записывается в нижнем регистре с использованием верблюжьей нотации `pageLoadTime`.  
Несколько хороших правил:
- использовать легко читаемые имена
- избегать использования аббревиатур или коротких имён
- делать имена максимально описательными или лаконичными  

#### Типы данных
Значения в js всегда относятся к данным определенного типа. Есть 8 основных типов данных. Переменная в js может содержать любые данные. Языки программирования, в которых такое возможно, называются "динамически типизированными". Это значит, что типы данных есть, но переменные не привязаны ни к одному из них.
###### Число
Числовой тип дынных (number) представляет как целочисленные значения, так и числа с плавающей точкой. Также существуют "специальные числовые значения": `Infinity`, `-Infinity` и `NaN`.
- `Infinity` представляет собой математическую бесконечность. Это особое значение, которое больше любого числа. Получить его можно в результате деления на ноль или задать его явно: `alert(1 / 0); alert( Infinity );`
- `NaN` означает вычислительную ошибку. Это результат неправильной или неопределенной математической операции: `alert( "не число" / 2 );`. Любая операция с `NaN` возвращает `NaN`.
> Математические операции в js безопасны. Скрипт никогда не остановиться с фатальной ошибкой. В худшем случае мы получим `NaN` как результат выполнения.
###### BigInt
В js тип `number` не может содержать числа больше, чем `9007199254740991`. Это техническое ограничение вызвано их внутренним представлением. Для большинства случаев этого достаточно, но иногда нужны гигантские числа, например в криптографии. Чтобы создать значение типа `BigInt`, необходимо добавить `n` в конец числового литерала `const bigInt = 1234567890123456789012345678901234567890n;`.  
> В данный момент `BigInt` поддерживает только в браузерах Firefox, Chrome и Edge, но не поддерживается в Safari и IE.
###### Строка
Строка должна быть заключена в кавычки. Существует три типа кавычек:
- Двойные "Привет"
- Одинарные 'Привет'
- Обратные `Привет`  
Двойные или одинарные являются "простыми", между ними нет разницы для Js. Обратные имеют расширенную функциональность. Они позволяют встраивать выражения в строку, заключая их `${...}`.  
> В некоторых языках, для хранения одного символа, существует отдельный тип. В JS такого типа нет, есть только `string`. Строка может содержать 0 символов (быть пустой), один символ или множество.
###### Булевый (логический) тип
Может принимать только два значения: `true` или `false`. Булевые значения также иогут быть результатом сравнений, `let isGreater = 4 > 1`.
###### Значение "null"
Специальное значение, которое не относится ни к одному из типов. Оно формирует отдельный тип, который содержит только значение `null`. В JS `null` не является "ссылкой на существующий объект" или "нулевым указателем", как в других языках. Это просто специальное значение, которое представляет собой "ничего", "пусто" или "значение неизвестно".
###### Значение "undefined"
Специальное значение, оно формирует тип из самого себя так же, как и `null`. Оно означает, что "значение не было присвоено". Если переменная объявлена, но ей не присвоено никакого значения, то её значением будет `undefined`:
```js
let age;

alert(age); // выведет "undefined"
```
Технически можно присвоить значение `undefined` любой переменной, но так делать не рекомендуется. Обычно `null` используется для присвоения переменной "пустого" или "неизвестного" значения, а `undefined` - для проверок, была ли переменная назначена.
###### Объекты и символы
Тип `object` - особенный. Все остальные типы - примитивные, потому что их значениями могут быть только простые значения. В объектах же хранятся коллекции или более сложные структуры данных.
Тип `symbol` используется для создания уникальных идентификаторов в объектах.
###### Оператор typeof
Оператор `typeof` возвращает тип аргумента. Синтаксические формы:
- оператор: `typeof x`
- функция: `typeof(x)`  
Вызов `typeof` возвращает строку с именем типа:
```js
typeof undefined // "undefined"

typeof 0 // "number"

typeof 10n // "bigint"

typeof true // "boolean"

typeof "foo" // "string"

typeof Symbol("id") // "symbol"

typeof Math // "object"  (1)

typeof null // "object"  (2)

typeof alert // "function"  (3)
```
1. `Math` - это встроенный объект, который предоставляет математические операции и константы.
2. Результатом вызова `typeof null` является `object`. Это официально признанная ошибка.
3. `Alert` возвращает `function`, потому что `alert` является функцией. В JS нет специального типа "функция". Функции относятся к объектному типу. Но `typeof` обрабатывает их особым образом, возвращая `"function"`.
###### Итого
В JS есть 8 основных типов:
- `number` для любых чисел: целочисленных или чисел с плавающей точкой; целочисленные значения ограничены диапазоном `±(253-1)`.
- `bigint` для целых чисел произвольной длины.
- `string` для строк. Строка может содержать ноль или больше символов, нет отдельного символьного типа.
- `boolean` для `true` / `false`.
- `null` для неизвестных значений – отдельный тип, имеющий одно значение null.
- `undefined` для неприсвоенных значений – отдельный тип, имеющий одно значение `undefined`.
- `object` для более сложных структур данных.
- `symbol` для уникальных идентификаторов.
Оператор typeof позволяет нам увидеть, какой тип данных сохранён в переменной.
- Имеет две формы: `typeof x` или `typeof(x)`.
- Возвращает строку с именем типа. Например, `"string"`.
- Для `null` возвращается `"object"` – это ошибка в языке, на самом деле это не объект.

#### Взаимодействие: alert, prompt, confirm
###### alert
`alert("Hello");`  
Она показывает сообщение и ждёт, пока пользователь нажмёт кнопку "Ок".
###### prompt
`result = prompt(title, [default]);`  
Отобразит модальное окно с текстом, полем для ввода и кнопками ОК/Отмена. `title` - текст для отображения в окне. `default` - необязательный параметр, уст. начальное значение в поле для текста.
> Квадратные скобки в синтаксисе `[...]` означают, что параметр факультативный, необязательный.  

Если пользователь напечатает что-либо в окне и нажмет ОК, то введенный текст будет присвоен переменной `result`. Если пользователь нажмет "Отмена" или клавишу `Esc` то переменной будет присвоено значение `null`.
###### confirm
`result = confirm(question);`  
Отображает модальное окно с текстом `question` и двумя кнопками: ОК и Отмена. Вернет `true`, если нажата кнопка ОК или `false` если "Отмена".
###### Все эти методы являеются модальными: останавливают выполнение скриптов и не позволяют пользователю взаимодействовать с остальной частью страницы до тех пор, пока окно не будет закрыто.  
Ограничения:
- расположение окон определяется браузером
- визуальное отображение нельзя изменить  
#### Преобразование типов
Чаще всего операторы и функции автоматически приводят переданные им значения к нужноиу типу. Например, `alert` автоматически преобразует любое значение в строку. Математические операторы к числу.
###### Строковое преобразование
`String(value);`  
Когда требуется представление чего-либо в виде строки. Преобразование происходит очевидным образом: `false` становиться `"false"`, `null` становиться `"null"` и т.п.
###### Численное преобразование
Происходит в математ. функциях и выражениях. Можно использовать функцию `Number(value)`. Явное преобразование чаще применяется, когда мы ожидаем получить число из строкового контекста. Если строка не может быть явно приведена к числу, то результатом будет `NaN`.  
Правила численного преобразования:  
Значение           | Преобразуется в...
------------------ | -------------
`undefined`        | `NaN`
`null`             | `0`
`true` / `false`   | `1` / `0`
`string`           | Пробельные символы по краям обрезаются. Если остается пустая строка - `0`, иначе из непустой строки считывается число. При ошибке результат `NaN`.  

Большинство матем. операторов также производит данное преобразование.
###### Логическое преобразование
Происходит в логических операциях, но также может быть выполнено явно: `Boolean(value)`.  
Правила преобразования:  
Значение                                                                                 | Преобразуется в...
---------------------------------------------------------------------------------------- | -------------
Значения, которые интуитивно "пустые": `0`, `undefined`, `""`, `null` и `NaN`            | `false`
Все остальные значения                                                                   | `true`  

Заметим:
- Строка с нулём `"0"` - это `true`
- Строка с пробелом `" "` - это тоже `true` (любая непустая строка это true)
###### Итого
3 типа преобразований: строковое, численное и логическое.
- `Строковое` - происходит, когда нам нужно что-то вывести. Для примитивных значений работает очевидным образом.
- `Численное` - происходит в матем. операциях.
- `Логическое` - происходит в логических операциях.
#### Базовые операторы, математика
###### Термины: "унарный", "бинарный", "операнд"
*Операнд* - то, к чему применяется оператор.  
*Унарным* - называется оператор, кот. применяется к одному операнду. `let x = 1; x = -x; // оператор отрицания`  
*Бинарным* - называется оператор, кот. применяется к двум операндам. `y - x; // оператор вычитания`  
###### Математика
- сложение `+`
- вычитание `-`
- умножение `*`
- деление `/`
- взятие остатка от деления `%`
- возведение в степень `**`
###### Взятие остатка %
Результат `a % b` - это остаток от целочисленного деления `a` на `b`.  
`alert( 5 % 2 ); // 1, остаток от деления 5 на 2`  
###### Возведение в степень **
В выражении `a ** b` оператор возведения в степень умножает `a` на само себя `b` раз: `alert( 2 ** 4 ); // (2 * 2 * 2 * 2)`.  
Математически, оператор работает и для нецелых чисел: `4 ** (1/2); // 2 (степень 1/2 эквивалентна взятию квадратного корня)`.
###### Сложение строк при помощи бинарного +
Если бинарный оператор `+` применить к строкам, то он их объединяет в одну: `let s = "моя" + "строка"; // моястрока`.  
Если хотя бы один операнд является строкой, то второй тоже будет преобразован в строку: `"1" + 2; // "12"`.
Операторы работают один за другим: `2 + 2 + "1"; // будет "41", а не "221"`.  
Сложение и преобразование строк - это особенность бинарного плюса `+`. Другие арифметические операторы работают только с числами и всегда преобразуют операнды в числа.
###### Приведение к числу, унарный +
Унарный плюс `+` ничего не делает с числами, но если операнд не число, унарный плюс преобразует его в число.
```js
+true; // 1
+""; // 0
```
Тоже самое, что и `Number(...)`, только короче.
```js
+apples + +oranges; // оба операнда предварительно преобразованы в числа
```
###### Приоритет операторов
Порядок выполнения операторов определяется *приоритетом*. Можно также использовать скобки, чтобы изменить приоритет. Если приоритет одинаковый, то порядок выполнения - слева направо.
Приоритет | Название | Обозначение
--------- |--------- | -----------
17 | унарный плюс | `+`
17 | унарный минус | `-`
16 | возведение в степень | `**`
15 | умножение | `*`
15 | деление | `/`
13 | сложение | `+`
13 | вычитание | `-`
3 | присваивание | `=`  

###### Присваивание
У него один из самых низких приоритетов. Поэтому, когда переменной что-либо присваивают, например `x = 2 * 2 + 1`, то сначала выполниться арифметика, а уже затем произойдет присваивание `=` с сохранением результата в `x`.
###### Присваивание = возвращает результат
Большинство операторов в JS возвращают значение. Оператор `=` не является исключением.  
Вызов `x = value` записывает `value` в `x` и *возвращает его*.
```
let a = 1;
let b = 2;

let c = 3 - (a = b + 1);
```
Результатом `(a = b + 1)` будет значение, которое присваивается переменной `a` (то есть `3`). Потом оно используется для дальнейших вычислений.
###### Сокращенная арифметика с присваиванием
Краткие записи существуют для всех арифметических и побитовых операторов: `/=, -=, *=, +=` и так далее. Вызов с присваиванием имеет в точности такой же приоритет, как обычное присваивание, то есть выполниться после большинства других операций: `n *= 3 + 5; // сначала выполниться правая часть`
###### Инкремент\декремент
- **Инкремент** `++` увеличивает переменную на 1: `counter++; // работает как counter = counter + 1`
- **Декремент** `--` уменьшаем переменную на 1: `counter--; // работает как counter = counter - 1`
> **Важно:**  
Инкремент\декремент можно применить только к переменной. Попытка использовать его на значении, типа 5++, приведет к ошибке.

- "постфиксная форма": `counter++`
- "префиксная форма": `++counter`
Префиксная форма возвращает новое значение, а постфиксная форма возвращает старое (до увеличения / уменьшения числа).
```js
let counter = 1;
let a = ++counter; // 2
--------------------------
let counter = 1;
let a = counter++; // 1
```
- Если результат не используется, тогда без разницы какую форму использовать;
- Если нужно тут же использовать результат - префиксная форма;
- если нужно значение до увеличения/уменьшения - постфиксная форма.
> Можно использовать в любых выражениях. Их приоритет выше чем у большинства других операций: `let counter = 1; 2 * ++counter; // 4`

###### Побитовые операторы
Работают с 32-разрядными целыми числами на уровне их внутреннего представления. Эти операторы не являются чем-то специфичным для JS, они поддерживаются в большинстве языков программирования:
- AND(и) (`&`)
- OR(или) (`|`)
- XOR(побитовое исключающее или) (`^`)
- NOT(не) (`~`)
- LEFT SHIFT(левый сдвиг) (`<<`)
- RIGHT SHIFT(правый сдвиг) (`>>`)
- ZERO-FILL RIGHT SHIFT(правый сдвиг с заполнением нулями) (`>>>`)
Они используются редко, когда возникает необходимость оперировать с числами на очень низком (побитовом) уровне.
###### Оператор "запятая"
Предоставляет возможность вычислять несколько выражений, разделяя их запятой `,`. Каждое выражение выполняется, но возвращается результат только последнего. Например:
```js
let a = (1 + 2, 3 + 4);

alert( a ); // 7 (результат вычисления 3 + 4)
```
Первое выражение выполняется, а результат отбрасывается. Затем идет второе, выражение выполняется и возвращает результат.
> **Запятая имеет очень низкий приоритет**  
Ниже `=`, поэтому скобки важны в приведенном выше примере.  

Иногда используется в составе более сложных конструкций, чтобы сделать несколько действий в одной строке. Например: `for (a = 1, b = 3, c = a * b; a < 10; a++) { ... }; // три операции в одной строке`.  
Обычно это не улучшает читабельность кода.
#### Операторы сравнения
###### Результат сравнения имеет логический тип
- `true` - означает "да", "верно", "истнина"
- `false` - означает "нет", "неверно", "ложь" 
###### Сравнение строк
Чтобы определить, что одна строка больше другой, используется "алфавитный" или "лексикографический" порядок, другими словами сравниваются посимвольно.
```js
alert( 'Сонный' > 'Сон' ); // true
```
Алгоритм сравнения:
1. Сначала сравниваются первые символы строк.
2. Если первый символ первой строки больше (меньше), чем первый символ второй, то первая строка больше (меньше) второй. Сравнение завершено.
3. Если первые символы равны, то таким же образом сравниваются уже вторые символы строк. 
4. Сравнение продолжается, пока не закончится одна из строк.
5. Если обе строки заканчиваются одновременно, то они равны. Иначе, большей считается более длинная строка.
> Используется кодировка Unicode, а не настоящий алфавит
В JS строчные буквы больше заглавных, потому они имеют больший код во внутренней таблице кодирования.  

###### Сравнение разных типов
При сравнении значений разных типов JS приводит каждое из них к числу:
```js
alert( "2" > 1 ); // true, строка "2" становиться числом 2
```
Логическое значение `true` становиться `1`, а `false` - `0`.
###### Строгое сравнение
Использование обычного сравнения `==` может вызывать проблемы. Оно не отличает `0` от `false`. Это происходит из-за того, что операнды разных типов преобразуются оператором `==` к числу.  
**Оператор строгого равенства `===` проверяет равенство без приведения типов**.  
Если переменные имеют разные типы, то проверка немедленно вернет `false` без попытки их преобразования.
###### Сравнение с null и undefined
При строгом равенстве `===` эти значения различны, т.к. различны их типы.  
При нестрогом равенстве `==` эти значения равны друг другу и не равны никаким другим значениям. Это специальное правило языка.  
При использовании математических операторов и других операторов сравнения `< > <= >=` значения `null/undefined` преобразуются к числам: `null` становиться `0`, а `undefined` - `NaN`.
- с `undefined/null` использовать только строгое равенство
- не использовать сравнения `>= > < <=` с переменными, которые могут применять значения `null/undefined`
###### Итого
- операторы сравнения возвращают значения логического типа
- строки сравниваются посимвольно в лексикографическом порядке
- значения разных типов при сравнении приводятся к числу. Исключение составляет сравнение с помощью строгого равенства/неравенства
- значения `null` и `undefined` равны `==` друг другу и не равны любому другому значению
- хорошей идеей будет сделать отдельную проверку на `null/undefined`
#### Условное ветвление: if, '?'
Инструкция `if(...)` вычисляет условие в скобках и, если результат `true`, то выполняет блок кода. Инструкция преобразует результат к логическому типу.
#### Логические операторы
В JS есть 3 логических оператора: `||` (ИЛИ), `&&` (И) и `!` (НЕ). Данные операторы могут применяться к значениям любых типов. Полученный результат также может иметь любой тип.
###### || (ИЛИ)
В случае, если какой-либо из аргументов `true`, он вернет `true`, иначе `false`.  
Существует 4 возможные логические комбинации:
```js
alert( true || true ); // true
alert( false || true ); // true
alert( true || false ); // true
alert( false || false ); // false
```
###### ИЛИ "||" находит первое истинное значение
```js
result = value1 || value2 || value3;
```
Оператор выполняет след. действия:
- вычисляет операнды слева направо
- каждый операнд конвертирует в логическое значение. Если результат `true`, останавливается и возвращает исходное значение этого операнда.
- если все операнды явл. ложными (`false`), возвращает последний из них.  
Значения возвращаются в исходном виде, без преобразования. Другими словами, цепочка `||` возвращает первое истинное значение или последнее, если такое значение не найдено.
1. **Получение первого истинного значения из списка переменных или выражений**.
```js
let currentUser = null;
let defaultUser = "Jonh";

let name = currentUser || defaultUser || "unnamed";

alert( name ); // выбирается "Jonh" - первое истинное значение
```
2. **Сокращенное вычисление**  
Операндами м.б. как отдельные значения, так и произвольные выражения. ИЛИ вычисляет их слева направо. Вычисления останавливаются при достижении первого истинного значения. Это называется "сокращенным вычислением", поскольку второй операнд вычисляется только в том случае, если первого недостаточно для вычисления всего выражения.  
В приведенном ниже примере `x` не измениться:
```js
let x;

true || (x = 1);

alert(x); // undefined, потому что (x = 1) не вычисляется
```
Если бы первый аргумент имел значение `false`, то `||` приступил бы к вычислению второго и выполнил операцию присваивания.
###### && (И)
Возвращает `true`, если оба аргумента истинны, а иначе - `false`
###### И "&&" находит первое ложное значение
При нескольких подряд операторах:
```js
result = value1 && value2 && value3;
```
- Вычисляет операнды слева направо.
- Каждый операнд преобразует в логическое значение. Если результат `false`, останавливается и возвращает исходное значение этого операнда.
- Если все операнды были истинными, возвращает последний.
Другими словами, И возвращает первое ложное значение, Или последнее, если ничего не найдено.
> **Приоритет оператора `&&` больше, чем у `||`**  

Как и оператор ИЛИ, И `&&` может иногда заменять `if`:
```js
let x = 1;

(x > 0) && alert( 'Greater than zero!' );
```
`alert` сработает, если в левой части будет `true`.
###### ! (НЕ)
Оператор принимает один аргумент и выполняет след. действия:
1. Сначала приводит аргумент к логическому типу `true/false`.
2. Затем возвращает противоположное значение.
```js
alert( !true ); // false
alert( !0 ); / true
```
В частности, двойное НЕ используется для преобразования значений к логическому типу:
```js
alert( !!"non-empty string" ); // true
alert( !!null ); // false
```
То есть первое НЕ преобразует значение в логическое значение и возвращает обратное, а второе НЕ снова инвертирует его. В конце мы имеем простое преобразование значения в логическое. То же самое `Boolean`.
> Приоритет НЕ `!` является наивысшим из всех логических операторов, поэтому он всегда выполняется первым, перед `&&` или `||`.
#### Оператор объединения с null "??"
> **Новая возможность**
Эта возможность была добавлена недавно, в старых браузерах может понадобиться полифил.  

Представляет собой `??`. Результат выражения `a ?? b`:
- `а`, если значение `a` определено,
- `b`, если значение `a` не определено.
То есть оператор `??` возвращает первый аргумент, если он не `null/undefined`, иначе второй.
По сути это всего лишь новый более удобный синтаксис, по старому это может быть записано: `(a !== null && a != undefined) ? a : b;`.  
Можно также использовать последовательность из нескольких операторов `??`, чтобы получить первое значение из списка, которое не является `null/undefined`.
###### Сравнение с ||
Оператор ИЛИ `||` можно использовать для того же, что и `??`.
Важное различие между ними:
- `||` возвращает первое *истинное* значение.
- `??` возвращает первое *определенное* значение.
Проще говоря, оператор `||` не различает `false, 0, "", null/undefined`. Для него все они являются ложными значениями. Однако часто требуется использовать значение по умолчанию только тогда, когда переменная является `null/undefined`. Ведь именно тогда значение действительно неизвестно.не определено.
###### Приоритет
Имеет низкий приоритет `5`. Вычисляется до `=` и `?`, но после большинства других операций. Следует использовать скобки при работе с оператором `??`.
###### Использование ?? вместе с && или ||
JS запрещает использование оператора `??` вместе с `&&` и `||`, если только приоритет не указан явно в круглых скобках. Такое ограничение было описано в спецификациях языка, чтобы избежать ошибок при замене оператора `||` на `??`. Необходимо использовать круглые скобки, чтобы обойти это ограничение.
###### Итого
- Это быстрый способ выбрать первое "определенное" значение из списка.
- Имеет очень низкий приоритет
- Запрещено использовать с `||` или `&&` без скобок.
#### Циклы while и for
##### Цикл "while"
```js
while (condition) {
  // код
  // также называемый `телом цикла`
}
```
Код из тела цикла выполняется, пока условие `condition` истинно.  
Одно выполнение цикла называется *итерация*. Повторение цикла вечно невозможно, браузер остановит "подвисший" скрипт, а js на стороне сервера "убьет" процесс.  
Любое выражение или переменная может быть условием цикла, а не только сравнение: условие `while` вычисляется и преобразуется в логическое значение.  
> Фигурные скобки не требуются для тела цикла из одной строки.  

##### Цикл "do...while"
```js
do {
  // тело цикла
} while (condition);
```
Используется для размещения проверки условия под целом цикла. Цикл сначала выполнит тело, а затем проверит условие `condition`. Такая форма синтаксиса используется если необходимо чтобы тело цикла выполнилось **хотя бы один раз**, даже условие окажется ложным.
##### Цикл "for"
```js
for (начало; условие; шаг) {
  // тело цикла
}
```
*Начало* выполняется один раз, затем каждая итерация заключается в проверка условия, после которой выполняется *тело* и *шаг*.
```js
for (let i = 0; i < 3; i++) {
  alert(i);
}
```
> **Встроенное объявление переменной**
Такие переменные существуют только внутри цикла
##### Пропуск частей "for"
Любая часть `for` может быть пропущена: `for (;;) { // будет выполняться вечно }`. При этом точки с запятой должны присутствовать, иначе будет ошибка синтаксиса.
##### Прерывание цикла: "break"
Обычно цикл завершается при вычислении условия в `false`. Но можно выйти в любой момент с помощью директива `break`. Данная директива полностью прекращает выполнение цикла и передаёт управление на строку за его телом, то есть на `alert`. Отлично подходит для тех случаев, когда условие, по которому нужно прерваться, находиться посередине.
##### Переход к следующей итерации: continue
При её выполнении цикл не прерывается, а переходит к следующей итерации (если условие все еще истинно).
> Нельзя использовать `break/continue` с тернарным опертором `?`.  
##### Метки для break/continue
Это необходимо для того чтобы выйти из нескольких уровней цикла сразу. Метка имеет вид идентификатора с двоеточием перед циклом:
```js
labelName: for (...) {
  ...
}
```
Вызов `break <labelName>` ищет ближайший внешний цикл с такой меткой и переходит в его конец.
```js
outer: for (let i = 0; i < 3; i++) {

  for (let j = 0; j < 3; j++) {

    let input = prompt(`Значение на координатах (${i},${j})`, '');

    // если пустая строка или Отмена, то выйти из обоих циклов
    if (!input) break outer; // (*)

    // сделать что-нибудь со значениями...
  }
}

alert('Готово!');
```
Директива `continue` также может быть использована с меткой. В этом случае управление перейдет на следующую итерацию цикла с меткой.
> Метки не позволяют передавать управление в произвольное место кода. Вызов `break/continue` возможен только внутри цикла, и метка должна находиться где-то выше этой директивы.
###### Итого
3 вида циклов:
- `while` - проверяет условие перед каждой итерацией
- `do...while` - проверяет условие после каждой итерации
- `for (;;)` - проверяет условие перед каждой итерацией, есть возможность задать дополнительные настройки.
Чтобы организовать бесконечный цикл, используют конструкцию `while(true)`. При этом он, как и любой другой цикл, может быть прерван директивой `break`.  
Если на данный итерации цикла делать больше нечего, но полностью прекращать цикл не следует - используют директиву `continue`.  
Обе эти директивы поддерживают *метки*, которые ставятся перед циклом. Метки - единственный способ для `break/continue` выйти за пределы текущего цикла, повлиять на выполнение внешнего.  
Метки не позволяют прыгнуть в произвольное место кода, в JS нет такой возможности.
#### Конструкция "switch"
##### Синтаксис
Имеет один или более блоков `case` и необязательный блок `default`.
```js
switch(x) {
  case 'value1':  // if (x === 'value1')
    ...
    [break]

  case 'value2':  // if (x === 'value2')
    ...
    [break]

  default:
    ...
    [break]
}
```
- переменная `x` проверяется на строгое равенство значению `value1`, затем второму `value2` и так далее.
- если соответствие установлено - `switch` начинает выполняться от соответствующей директивы `case` и далее, до ближайшего `break` (или до конца `switch`).
- Если ни один `case` не совпал - выполняется (если есть) вариант `default`.
**Если `break` нет, то выполнение пойдет ниже по следующим `case`, при этом остальные проверки игнорируются.**
```js
let a = 2 + 2;

switch (a) {
  case 3:
    alert( 'Маловато' );
> case 4:
>   alert( 'В точку!' );
> case 5:
>   alert( 'Перебор' );
> default:
>   alert( "Нет таких значений" );
}
```
Последовательно выполняться три `alert`.
> Любое выражение можно использовать в качестве аргумента для `switch/case`:
```
switch (+a) {
  case b + 1:
    // alert
    break;
}
```
##### Группировка "case"
Несколько вариантов `case`, использующих один код, можно группировать.
```js
switch (a) {
  case 4:
    alert("Правильно!");
    break;
  
  case 3:
  case 5:
    alert("Неправильно!");
    break;
}
```
##### Тип имеет значение
Проверка на равенство всегда строгая, значения должны быть одного типа, чтобы выполнялось равенство.
#### Функции
##### Объявление функции
Для создания функции используется объявление функции.
```js
function showMessage() {
  alert( 'Всем привет!' );
}
```
Сначала идет ключевое слово `function`, после него имя *функции*, затем список *параметров* в круглых скобках через запятую и также *тело функции*, внутри фигурных скобок. Функция может быть вызвана по ее имени.
##### Локальные переменные
Переменные объявленные внутри функции, видны только внутри этой функции.
```js
function showMessage() {
  let message = "Привет, я JavaScript!"; // локальная переменная

  alert( message );
}
```
##### Внешние переменные
Но у функции есть доступ к внешним переменным.
```js
let userName = 'Вася';

function showMessage() {
  let message = 'Привет, ' + userName;
  alert(message);
}
```
Функция имеет полный доступ к внешним переменным и может изменять их значение.  
Внешняя функция используется, только если нет такой локальной. Если одноимённая переменная объявляется внутри функции, тогда она перекрывает внешнюю.
> **Глобальные переменные**
Переменные, объявленные снаружи всех функций - называются *глобальными*. Глобальные функции видны для любой функции. Иногда глобальные функции важны для хранения "общепроектовых" данных.  
##### Параметры
Внутрь функции можно передать любую информацию используя параметры (аргументы).
```js
function showMessage(from, text) { // аргументы: from, text
  alert(from + ': ' + text);
}

showMessage('Аня', 'Привет!'); // Аня: Привет! (*)
showMessage('Аня', "Как дела?"); // Аня: Как дела? (**)
```
Когда функция вызывается, переданные знаения копируются в локальные переменные `form` и `text`, затем они используются в теле функции. Фукнция всегда получаем тольку копию значения.
##### Параметры по умолчанию
Если параметр не указан, то его значением становиться `undefined`. Это не приведет к ошибке. Если нужно задать параметру значение по умолчанию, нужно указаь его после `=`:
```js
function showMessage(from, text = "текст не добавлен") {
  alert( from + ": " + text );
}
```
Теперь если параметр не указан, его значением будет `"текст не добавлен"`. Вместо значения по умолчанию можно подставить более сложное выражение, которое бы вычичлялось и присваивалось при отсутствии параметра.
> В JS параметры по умолчанию вычисляются каждый раз, когда функция вызывается без соответствующего параметра.
##### Возврат значения
Функция может вернуть результат, который будет передан в вызвавший её код.
```js
function sum(a, b) {
  return a + b;
}
```
Директива `return` может находиться в любом месте тела функции. Как только выполнение доходит до этого места, фукнция останавливается, и значение возвращается в вызвавший её код.  
Возможно использовать `return` и без значения. Это приведет к немедленному выходу из функции.
> **Результат функции с пустым `return` или без него - `undefined`**.  

> **Никогда не добавлять перевод строки между `return` и его значением**
##### Выбор имени функции
Функция - это действие. Поэтому обычно это глагол. Оно должно быть простым, точным и описывать действие функции. Как правило описывают глагольные префиксы, обозначающие общий характер действия, после которых следует уточнение.  
Функции, начинающиеся с...
- `get` - возвращают значение,
- `calc` - вычисляют,
- `create` - создают,
- `check` - проверяют и возвращают логическое значение
> **Одна функция - одно действие**
Функция должна делать только то, что явно подразумевается её названием. И это должно быть одним действием.  
Два независимых действия обычно подразумевают две функции, даже если предпологается, что они будут вызываться вместе (в этом случае мы можем создать третью функцию, которая будет их вызывать).
Несколько примеров нарушающих правила:
- `getAge` - будет плохим выбором, если функция будет выводить `alert` с возрастом (должна только возвращать его).
- `createForm` - будет плохим выбором, если функция будет изменять документ, добавляя форму в него (должна только создавать форму и возвращать её).
- `checkPermission` - плохой вариант, если будет отображать сообщение с текстом `доступ разрешен/запрещен` (должна только выполнять проверку и возвращать ее результат)
##### Функции == Комментарии
Если функция большая, имеет смысл разбить функцию на несколько меньших. Небольшие функции не только облегчают тестирование и отладку, но и выполняет роль хороших комментариев. Иногда такой код называют *самодокументируемым*.  
Таким образом допустимо создавать функции, даже если мы не планируем повторно использовать их. Такие функции структурируют код и делают его более понятным.
#### Function Expression
Обычный синтаксис который мы использовали, называется *Function Declaration (Объявление функции)*.
```js
function sayHi() {
  alert( "Привет" );
}
```
Еще один синтаксис создания функций, назыавется *Function Expression* (Функциональное выражение).
```js
let sayHi = function() {
  alert( "Привет" );
};
```
Функция создается и явно присавивается переменной. По сути разницы никакой нет, это просто значение, хранимое в переменной.
```js
alert( sayHi ); // (1)
```
(1) данная строка не вызывает функцию `sayHi`, после ее имени нет круглых скобок. В JS функции это значения. Код выше выведет строковое представление функции, которое является её исходным кодом.  
Конечно функция - не обычное значение и мы можем вызвать его при помощи скобок: `sayHi()`.
Но все же это значение, поэтому с ним можно обращаться как и с другими значениями. Например, скопировать функцию в другую переменную.
```js
function sayHi() {   // (1) создаём
  alert( "Привет" );
}

let func = sayHi;    // (2) копируем

func(); // Привет    // (3) вызываем копию (работает)!
sayHi(); // Привет   //     прежняя тоже работает (почему бы нет)
```
> **Зачем нужна точка с запятой в конце?**  
- Нет необходимости в `;` в конце блоков кода и синтаксических конструкций, которые их используют, таких как `if {...}`, `for {...}` и т.д.
- Function Expression использует внутри себя инструкции присваивания `let sayHi = ...;` как значение. Это не блок кода, а выражение с присваиванием. Т.о., точка с запятой не относиться непосредственно к Function Expression, она лишь завершает инструкцию.  

##### Функции - "колбэки"
Ключевая идея в том, что мы передаем фукнцию и ожидаем, что она вызовется обратно когда-нибудь позже, если это будет необходимо.
> **Функция - это значение, представляющее "действие"**
Обычные значения, такие как строки или числа представляют собой данные. Фукнции с другой стороны, можно воспринимать как "действия". Мы можем передавать их из переменной в переменную и запускать, когда захотим.
##### Различия FE от FD
- FD: объявляется отдельной конструкцией "function..." в основном потоке кода.
- FE: создается внутри другого выражения или синтаксической конструкции.
- FE создается, когда выполнение доходит до него, и затем уже может использоваться.
- FD можно использовать во всем скрипте (или блоке кода, если функция объявлена в блоке).
- В строгом режиме, когда FD находится в блоке `{...}`, функция доступна везде внутри блока, но не снаружи него. Верным подходом будет воспользоваться функцией, объявленной при помощи FE, и просвоить значение переменной, объявленной снаружи `{...}`, что обеспечит нам нужную видимость.
> **Когда что использовать ?**
Как правило, когда понадобилась функция, в первую очередь нужно рассматривать синтаксис FD. Он дает больше свободы в том, как мы можем организовывать код.
##### Итого
* Функции - это значения, они могут быть присвоены, скопированы или объвлены в другом месте кода.
* Если функция объвлена как отдельная инструкция в основном потоке кода, то это FD.
* Если функция была создана как часть выражения, то считается, что это FE.
* FD обрабатывается перед выполнением блока кода. Они видны во всём блоке кода.
* FE создаются только когда поток выполнения достигает их.
#### функции-стрелки, основы (arrow function)
```js
let func = (arg1, arg2, arg3) => expression
```
Создается функция `func` с аргументами `arg1...argN` и вычисляет `expression` с правой стороны с их использованием, возвращая результат.
* Если только один агрумент, то круглые скобки вокруг параметров можно опустить
* Если аргументов нет, указываются пустые скобки
* Могут быть использованы так же, как и FE
##### Многострочные стрелочные функции
Это также возможно, нужно лишь заключить инструкции в фигурные скобки и использовать `return` внутри них.
##### Итого
Очень удобны для однострочных действий.
#### Особенности JS
##### [Структура кода](https://learn.javascript.ru/structure)
* Инструкции разделяются `;`
* Перевод строки также интерпретируется как разделитель. Так называемая "автоматическая вставка точки с запятой"
* Точка с запятой не требуется после блоков кода `{...}` и синтаксических конструкций с ними
##### [Строгий режим](https://learn.javascript.ru/strict-mode)
Все скрипты рекомендуется начинать с директивы `use strict`. Стоит размещать в первой строке скрипта или в начале тела функции. Без него некоторые возможности будуть работаь в "режиме совместимости". Некоторые конструкции языка включают стогий режим по умолчанию.
##### [Переменные](https://learn.javascript.ru/variables), [Типы данных](https://learn.javascript.ru/types)
Объявление: `let, const, var`. Имена переменных могут вкл.:
- буквы и цифры, но цифра не может быть первым символом
- символы `$` и `_` используются наряду с буквами
- иероглифы и символы нелатинского алфавита также допустимы, но обычно не используются
Переменные типизируются динамически и могут хранить любые значения.
Типы данных:
- `number` для целых и вещественных чисел
- `bigint` для работы с целыми числами произвольной длины
- `string` для строк
- `boolean` для логических значений `true/false`
- `null` - тип с единственным значением `null` - "пустое значение" или "значение не существует"
- `undefined` - тип с единственным значением `undefined` - "значение не задано"
- `object` и `symbol` - структура данных и уникальный идентификатор
Оператор `typeof` возвращает тип значения переменной. Исключения:
```js
typeof null == "object" // ошибка в языке
typeof function(){} == "function" // именно для функций
```
##### Операторы
###### Арифметические
Простые `* + - /`, а также деление по модулю `%` и возведение в степень `**`.
Бинарный плюс `+` объединяет строки. Если одним из операндов является строка, то второй тоже будет конвертирован в строку.
###### Операторы присваивания
Простые `a = b` и составные `a *= 2`
###### Битовые операции
Битовые операции работают с 32-битными целыми числами на самом низком, побитовом уровне.
###### Условный оператор
Единственный оператор с тремя параметрами: `cond ? resultA : resultB`
###### Логические операторы
`&&` и `||` используют ленивое вычисление и возвращают значение на котором оно остановилось. Логическое НЕ `!` конвертирует операнд в логический тип и возвращает инвертированное значение.
###### Сравнение
Проверка на равенство `==` значений разных типов конвертирует их в число, за исключение `null` и `undefined`, которые могут равняться только друг другу.  
Оператор строгого равенства `===` не выполняет конвертирование: разные типы для него всегда означают разные значения.  
Значения `null` и `undefined` равны только друг другу, но не равны ничему еще.  
Операторы сравнения больше/меньше сравнивают строки посимвольно, остальные типы конвертируются в число.  

Подробности: [Базовые операторы, математика](https://learn.javascript.ru/operators), [Операторы сравнения](https://learn.javascript.ru/comparison), [Логические операторы](https://learn.javascript.ru/logical-operators).
##### Циклы
Три вида:
```js
// 1
while (condition) {
  ...
}

// 2
do {
  ...
} while (condition);

// 3
for(let i = 0; i < 10; i++) {
  ...
}
```
* Переменная объвленная в цикле, видна только внутри цилка. Но можно опустить перменную и переиспользовать существующую.
* Директивы `break/continue` позволяют выйти из цикла/текущей итерации. Можно использовать метки для выхода из вложенных циклов.

Подробности: [Циклы while и for](https://learn.javascript.ru/while-for).
##### Конструкция "switch"
Пир сравнении она использует оператор строгого равенства `===`.

Подробности: [Конструкция "switch"](https://learn.javascript.ru/switch).
##### Функции
Три способа создания:
1. Function Declaration: функция в основном потоке кода
2. Function Expression: функция как часть выражения
3. Стрелочные функции
* У функций м.б. локальные переменные, т.е. объявленные в теле функции. Видны только внутри функции.
* У параметров м.б. значения по умолчанию.
* Функция всегда что-то возвращает. Если нет оператор `return`, результатом будет `undefined`.
